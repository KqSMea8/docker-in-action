

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="cn" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="cn" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. 实践 &mdash; docker-in-action 0.1.alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5. 附录" href="appendix.html" />
    <link rel="prev" title="3. 基本操作" href="basic_cmd.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> docker-in-action
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Getting Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_concept.html">2. 基本概念</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_cmd.html">3. 基本操作</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. 实践</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">4.1. 概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">4.2. 准备工作</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">4.2.1. 开发环境</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">4.2.2. 开发工程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id6">4.3. 镜像</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">4.3.1. 制作镜像</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">4.3.1.1. 基础镜像</a></li>
<li class="toctree-l4"><a class="reference internal" href="#build-context">4.3.1.2. 构建上下文(build context)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dockerfile">4.3.1.3. Dockerfile指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">4.3.1.4. 构建镜像</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id10">4.3.2. 镜像管理</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id11">4.4. 部署</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mysql">4.4.1. mysql</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fp-backend">4.4.2. fp-backend</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fp-frontend">4.4.3. fp-frontend</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">5. 附录</a></li>
<li class="toctree-l1"><a class="reference internal" href="training.html">6. 培训材料</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">docker-in-action</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>4. 实践</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/docker/practice.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>4. 实践<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>4.1. 概述<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>该章节通过两个模拟服务(<code class="docutils literal notranslate"><span class="pre">fp-frontend</span></code>和<code class="docutils literal notranslate"><span class="pre">fp-backend</span></code>)，介绍如何做容器化改造，穿插介绍Docker相关的知识和使用方法，以及如何部署，如何解决服务依赖等。主要包括:</p>
<ul class="simple">
<li>镜像制作(Dockerfile)</li>
<li>镜像管理</li>
<li>容器部署</li>
<li>服务依赖</li>
<li>网络配置</li>
<li>数据持久化</li>
</ul>
</div>
<div class="section" id="id3">
<h2>4.2. 准备工作<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id4">
<h3>4.2.1. 开发环境<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>由于是从开发态制作镜像，需要准备好开发环境。模拟服务都是使用<code class="docutils literal notranslate"><span class="pre">java</span></code>语言开发，基于<code class="docutils literal notranslate"><span class="pre">maven</span></code>做依赖包管理。</p>
<ul class="simple">
<li>JDK</li>
</ul>
<p>模拟服务中使用的是 <code class="docutils literal notranslate"><span class="pre">1.8.0_181</span></code> 版本。</p>
<p>从Oracle<a class="reference external" href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">官网</a>下载对应的tar.gz二进制包，在本地解压，配置下JAVA_HOME即可。
执行<code class="docutils literal notranslate"><span class="pre">java</span> <span class="pre">-version</span></code>验证。输出如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">java</span> <span class="n">version</span> <span class="s2">&quot;1.8.0_181&quot;</span>
<span class="n">Java</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span> <span class="n">SE</span> <span class="n">Runtime</span> <span class="n">Environment</span> <span class="p">(</span><span class="n">build</span> <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_181</span><span class="o">-</span><span class="n">b13</span><span class="p">)</span>
<span class="n">Java</span> <span class="n">HotSpot</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span> <span class="mi">64</span><span class="o">-</span><span class="n">Bit</span> <span class="n">Server</span> <span class="n">VM</span> <span class="p">(</span><span class="n">build</span> <span class="mf">25.181</span><span class="o">-</span><span class="n">b13</span><span class="p">,</span> <span class="n">mixed</span> <span class="n">mode</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>maven</li>
</ul>
<p>模拟服务中使用的是<code class="docutils literal notranslate"><span class="pre">3.5.4</span></code>版本。</p>
<p>从Apache<a class="reference external" href="https://maven.apache.org/download.cgi">官网</a>下载二进制包，在本地解压，配置M2_HOME和PATH即可。
执行<code class="docutils literal notranslate"><span class="pre">mvn</span> <span class="pre">-v</span></code>验证。输出如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Apache</span> <span class="n">Maven</span> <span class="mf">3.5</span><span class="o">.</span><span class="mi">4</span> <span class="p">(</span><span class="mi">1</span><span class="n">edded0938998edf8bf061f1ceb3cfdeccf443fe</span><span class="p">;</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">18</span><span class="n">T02</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">14</span><span class="o">+</span><span class="mi">08</span><span class="p">:</span><span class="mi">00</span><span class="p">)</span>
<span class="n">Maven</span> <span class="n">home</span><span class="p">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">llliu</span><span class="o">/</span><span class="n">workspace</span><span class="o">/</span><span class="n">maven</span>
<span class="n">Java</span> <span class="n">version</span><span class="p">:</span> <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_181</span><span class="p">,</span> <span class="n">vendor</span><span class="p">:</span> <span class="n">Oracle</span> <span class="n">Corporation</span><span class="p">,</span> <span class="n">runtime</span><span class="p">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">llliu</span><span class="o">/</span><span class="n">workspace</span><span class="o">/</span><span class="n">jdk8</span><span class="o">/</span><span class="n">jre</span>
<span class="n">Default</span> <span class="n">locale</span><span class="p">:</span> <span class="n">en_US</span><span class="p">,</span> <span class="n">platform</span> <span class="n">encoding</span><span class="p">:</span> <span class="n">UTF</span><span class="o">-</span><span class="mi">8</span>
<span class="n">OS</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;linux&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">:</span> <span class="s2">&quot;4.15.0-33-generic&quot;</span><span class="p">,</span> <span class="n">arch</span><span class="p">:</span> <span class="s2">&quot;amd64&quot;</span><span class="p">,</span> <span class="n">family</span><span class="p">:</span> <span class="s2">&quot;unix&quot;</span>
</pre></div>
</div>
<p>使用的maven仓库是阿里云的，仓库地址配置如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">mirrors</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">mirror</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="n">nexus</span><span class="o">-</span><span class="n">aliyun</span><span class="o">&lt;/</span><span class="nb">id</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">mirrorOf</span><span class="o">&gt;</span><span class="n">central</span><span class="o">&lt;/</span><span class="n">mirrorOf</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="n">Nexus</span> <span class="n">aliyun</span><span class="o">&lt;/</span><span class="n">name</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">url</span><span class="o">&gt;</span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">maven</span><span class="o">.</span><span class="n">aliyun</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">nexus</span><span class="o">/</span><span class="n">content</span><span class="o">/</span><span class="n">groups</span><span class="o">/</span><span class="n">public</span><span class="o">&lt;/</span><span class="n">url</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">mirror</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">mirrors</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>将上述配置增加至 <code class="docutils literal notranslate"><span class="pre">$M2_HOME/conf/settings.xml</span></code> 中。</p>
</div>
<div class="section" id="id5">
<h3>4.2.2. 开发工程<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://gitlab.yitu-inc.com/devops/observability/fp-frontend">fp-frontend</a></li>
<li><a class="reference external" href="http://gitlab.yitu-inc.com/devops/observability/fp-backend">fp-backend</a></li>
</ul>
</div>
</div>
<div class="section" id="id6">
<h2>4.3. 镜像<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>该章节介绍如何制作Docker镜像和镜像管理。</p>
<div class="section" id="id7">
<h3>4.3.1. 制作镜像<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>在基本概念中介绍过，Docker镜像其实是一个特殊的文件系统，采用分层结构存储，是一组文件系统的组合。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p>
<p>所以，制作镜像的过程，就是在编排如何修改、增加文件或者配置，形成一个新的文件层。将这些编排动作写入一个脚本，这个脚本就是<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的<code class="docutils literal notranslate"><span class="pre">指令(Instruction)</span></code>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<div class="section" id="id8">
<h4>4.3.1.1. 基础镜像<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>既然是定制文件系统，自然就需要有个root fs，这个root fs就是基础镜像。基础镜像的引入是通过<code class="docutils literal notranslate"><span class="pre">FROM</span></code>指令。因此，一个<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>中，必须有<code class="docutils literal notranslate"><span class="pre">FROM</span></code>指令，而且必须是第一条指令。</p>
<p>在<a class="reference external" href="https://hub.docker.com/">docker hub</a>镜像仓库中，有很多基础镜像，例如  <code class="docutils literal notranslate"><span class="pre">nginx</span></code>，<code class="docutils literal notranslate"><span class="pre">nodejs</span></code>，<code class="docutils literal notranslate"><span class="pre">ubuntu</span></code>。在<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>中通过<code class="docutils literal notranslate"><span class="pre">FROM</span> <span class="pre">&lt;image_name&gt;:&lt;image_tag&gt;</span></code>指令即可引用基础镜像。例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">14.04</span>
</pre></div>
</div>
<p>其中，<code class="docutils literal notranslate"><span class="pre">ubuntu</span></code>是镜像名称(image_name)，<code class="docutils literal notranslate"><span class="pre">14.04</span></code>是镜像tag(image_tag)。</p>
<blockquote>
<div>说明: 引用基础镜像时，必须带上 <code class="docutils literal notranslate"><span class="pre">image_tag</span></code>，不得使用 <code class="docutils literal notranslate"><span class="pre">latest</span></code>，防止在重复构建时，基础镜像变更导致构建的版本差异。</div></blockquote>
<p>下面，来构建第一个镜像。</p>
<ul>
<li><p class="first">首先，在工程跟目录下创建<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>文件。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 以 fp_frontend　工程为例</span>
<span class="c1">## 进入工程根目录</span>
<span class="n">cd</span> <span class="n">fp_frontend</span>

<span class="c1">## 创建Dockerfile文件</span>
<span class="n">touch</span> <span class="n">Dockerfile</span>
</pre></div>
</div>
</li>
<li><p class="first">编辑<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>，增加基础镜像。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 编辑文件</span>
<span class="n">vim</span> <span class="n">Dockerfile</span>

<span class="c1">## 增加基础镜像</span>
<span class="n">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">14.04</span>
</pre></div>
</div>
</li>
<li><p class="first">接着，增加一层操作。如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 执行shell命令(暂先不管RUN指令，后面会介绍)</span>
<span class="n">RUN</span> <span class="n">echo</span> <span class="s2">&quot;my first docker image.&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first">退出，保存<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>。</p>
</li>
<li><p class="first">构建镜像。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">demo</span><span class="o">-</span><span class="n">image</span><span class="p">:</span><span class="mf">0.1</span> <span class="o">.</span>
</pre></div>
</div>
<p>输出如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sending</span> <span class="n">build</span> <span class="n">context</span> <span class="n">to</span> <span class="n">Docker</span> <span class="n">daemon</span> <span class="mf">516.6</span> <span class="n">kB</span>
<span class="n">Step</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="p">:</span> <span class="n">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">14.04</span>
<span class="mf">14.04</span><span class="p">:</span> <span class="n">Pulling</span> <span class="kn">from</span> <span class="nn">library</span><span class="o">/</span><span class="n">ubuntu</span>
<span class="n">e53f134edff2</span><span class="p">:</span> <span class="n">Pull</span> <span class="n">complete</span> 
<span class="n">efbbd466a715</span><span class="p">:</span> <span class="n">Pull</span> <span class="n">complete</span> 
<span class="n">e11368b8e0c7</span><span class="p">:</span> <span class="n">Pull</span> <span class="n">complete</span> 
<span class="mi">7</span><span class="n">dab2de7692b</span><span class="p">:</span> <span class="n">Pull</span> <span class="n">complete</span> 
<span class="n">Digest</span><span class="p">:</span> <span class="n">sha256</span><span class="p">:</span><span class="n">cac55e5d97fad634d954d00a5c2a56d80576a08dcc01036011f26b88263f1578</span>
<span class="n">Status</span><span class="p">:</span> <span class="n">Downloaded</span> <span class="n">newer</span> <span class="n">image</span> <span class="k">for</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">14.04</span>
 <span class="o">---&gt;</span> <span class="mi">5</span><span class="n">dbc3f318ea5</span>
<span class="n">Step</span> <span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="p">:</span> <span class="n">RUN</span> <span class="n">echo</span> <span class="s2">&quot;my first docker image.&quot;</span>
 <span class="o">---&gt;</span> <span class="n">Running</span> <span class="ow">in</span> <span class="n">b5f02ed2d89a</span>
<span class="n">my</span> <span class="n">first</span> <span class="n">docker</span> <span class="n">image</span><span class="o">.</span>
 <span class="o">---&gt;</span> <span class="n">d66c9accb323</span>
<span class="n">Removing</span> <span class="n">intermediate</span> <span class="n">container</span> <span class="n">b5f02ed2d89a</span>
<span class="n">Successfully</span> <span class="n">built</span> <span class="n">d66c9accb323</span>
</pre></div>
</div>
</li>
<li><p class="first">查看镜像</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">images</span>
</pre></div>
</div>
<p>应该会有刚构建的镜像，以及引入的基础镜像，如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">REPOSITORY</span>                                      <span class="n">TAG</span>                 <span class="n">IMAGE</span> <span class="n">ID</span>            <span class="n">CREATED</span>             <span class="n">SIZE</span>
<span class="n">demo</span><span class="o">-</span><span class="n">image</span>                                      <span class="mf">0.1</span>                 <span class="n">d66c9accb323</span>        <span class="mi">55</span> <span class="n">seconds</span> <span class="n">ago</span>      <span class="mi">188</span> <span class="n">MB</span>
<span class="n">ubuntu</span>                                          <span class="mf">14.04</span>               <span class="mi">5</span><span class="n">dbc3f318ea5</span>        <span class="mi">2</span> <span class="n">weeks</span> <span class="n">ago</span>         <span class="mi">188</span> <span class="n">MB</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="build-context">
<h4>4.3.1.2. 构建上下文(build context)<a class="headerlink" href="#build-context" title="Permalink to this headline">¶</a></h4>
<p>上述构建镜像命令---<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-t</span> <span class="pre">demo-image:0.1</span> <span class="pre">.</span></code>，其中<code class="docutils literal notranslate"><span class="pre">.</span></code>表示当前目录，但是并不是指的是<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>所在的目录，而是指定的构建<code class="docutils literal notranslate"><span class="pre">上下文路径</span></code>。</p>
<p>首先我们要理解 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <code class="docutils literal notranslate"><span class="pre">RUN</span></code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code class="docutils literal notranslate"><span class="pre">COPY</span></code> 指令、<code class="docutils literal notranslate"><span class="pre">ADD</span></code> 指令等。而 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>例如上述例子中，将<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>拷贝至子目录中(test)，增加<code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">../pom.xml</span> <span class="pre">/tmp</span></code>指令，执行<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-t</span> <span class="pre">demo-image:0.2</span> <span class="pre">test</span></code>时，会发现报错:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sending</span> <span class="n">build</span> <span class="n">context</span> <span class="n">to</span> <span class="n">Docker</span> <span class="n">daemon</span> <span class="mf">2.048</span> <span class="n">kB</span>
<span class="n">Step</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="p">:</span> <span class="n">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">14.04</span>
 <span class="o">---&gt;</span> <span class="mi">5</span><span class="n">dbc3f318ea5</span>
<span class="n">Step</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span> <span class="p">:</span> <span class="n">RUN</span> <span class="n">echo</span> <span class="s2">&quot;my first docker image.&quot;</span>
 <span class="o">---&gt;</span> <span class="n">Using</span> <span class="n">cache</span>
 <span class="o">---&gt;</span> <span class="mi">15</span><span class="n">cbd1708462</span>
<span class="n">Step</span> <span class="mi">3</span><span class="o">/</span><span class="mi">3</span> <span class="p">:</span> <span class="n">COPY</span> <span class="o">../</span><span class="n">pom</span><span class="o">.</span><span class="n">xml</span> <span class="o">/</span><span class="n">tmp</span>
<span class="n">Forbidden</span> <span class="n">path</span> <span class="n">outside</span> <span class="n">the</span> <span class="n">build</span> <span class="n">context</span><span class="p">:</span> <span class="o">../</span><span class="n">pom</span><span class="o">.</span><span class="n">xml</span> <span class="p">()</span>
</pre></div>
</div>
<p>从中也可以看出，<code class="docutils literal notranslate"><span class="pre">test</span></code>目录即是构建上下文，<code class="docutils literal notranslate"><span class="pre">COPY</span></code>指令的源文件只能是相对于<code class="docutils literal notranslate"><span class="pre">test</span></code>目录的，不能超出该目录。</p>
<p>那么为什么会有人误以为 <code class="docutils literal notranslate"><span class="pre">.</span></code> 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 <code class="docutils literal notranslate"><span class="pre">-f</span></code>  参数指定某个文件作为 Dockerfile。例如: <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-t</span> <span class="pre">demo-image:0.2</span> <span class="pre">test/Dockerfile</span> <span class="pre">.</span></code>(使用test目录下的Dockerfile，但构建上下文是在当前目录)。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>
<p>上面提到<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code>时，会将构建上下文中的文件打包上传给Docker引擎。那如果当前有些文件不是构建需要的(尤其大文件，影响构建效率)，就可以使用<code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code>(类似<code class="docutils literal notranslate"><span class="pre">.gitignore</span></code>)排除不需要的文件。
例如，创建<code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code>，并增加<code class="docutils literal notranslate"><span class="pre">pom.xml</span></code>(执行<code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">pom.xml</span> <span class="pre">&gt;</span> <span class="pre">.dockerignore</span></code>)。再次执行<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-t</span> <span class="pre">demo-image:0.2</span> <span class="pre">.</span></code>时，会报错:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sending</span> <span class="n">build</span> <span class="n">context</span> <span class="n">to</span> <span class="n">Docker</span> <span class="n">daemon</span> <span class="mf">514.6</span> <span class="n">kB</span>
<span class="n">Step</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="p">:</span> <span class="n">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">14.04</span>
 <span class="o">---&gt;</span> <span class="mi">5</span><span class="n">dbc3f318ea5</span>
<span class="n">Step</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span> <span class="p">:</span> <span class="n">RUN</span> <span class="n">echo</span> <span class="s2">&quot;my first docker image.&quot;</span>
 <span class="o">---&gt;</span> <span class="n">Using</span> <span class="n">cache</span>
 <span class="o">---&gt;</span> <span class="mi">15</span><span class="n">cbd1708462</span>
<span class="n">Step</span> <span class="mi">3</span><span class="o">/</span><span class="mi">3</span> <span class="p">:</span> <span class="n">COPY</span> <span class="n">pom</span><span class="o">.</span><span class="n">xml</span> <span class="o">/</span><span class="n">app</span>
<span class="n">lstat</span> <span class="n">pom</span><span class="o">.</span><span class="n">xml</span><span class="p">:</span> <span class="n">no</span> <span class="n">such</span> <span class="n">file</span> <span class="ow">or</span> <span class="n">directory</span>
</pre></div>
</div>
</div>
<div class="section" id="dockerfile">
<h4>4.3.1.3. Dockerfile指令<a class="headerlink" href="#dockerfile" title="Permalink to this headline">¶</a></h4>
<p>除了引入基础镜像的<code class="docutils literal notranslate"><span class="pre">FROM</span></code>，还有一些常用的指令:</p>
<ul>
<li><p class="first">RUN</p>
<p><code class="docutils literal notranslate"><span class="pre">RUN</span></code>是用来执行命令行的，有两种格式:</p>
<ul class="simple">
<li>shell格式: <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">&lt;命令&gt;</span></code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</li>
<li>exec 格式：<code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">[&quot;可执行文件&quot;,</span> <span class="pre">&quot;参数1&quot;,</span> <span class="pre">&quot;参数2&quot;]</span></code>，这更像是函数调用中的格式。</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">RUN</span></code>是最常用的指令，例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span>
<span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">gcc</span> <span class="n">libc6</span><span class="o">-</span><span class="n">dev</span> <span class="n">make</span> <span class="n">wget</span>
<span class="n">RUN</span> <span class="n">wget</span> <span class="o">-</span><span class="n">O</span> <span class="n">redis</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span> <span class="s2">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span>
<span class="n">RUN</span> <span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">redis</span>
<span class="n">RUN</span> <span class="n">tar</span> <span class="o">-</span><span class="n">xzf</span> <span class="n">redis</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">redis</span> <span class="o">--</span><span class="n">strip</span><span class="o">-</span><span class="n">components</span><span class="o">=</span><span class="mi">1</span>
<span class="n">RUN</span> <span class="n">make</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">redis</span>
<span class="n">RUN</span> <span class="n">make</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">redis</span> <span class="n">install</span>
</pre></div>
</div>
<p>按照之前所说，<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>中每执行一条指令，就会建立一层。像上面，执行构建时，就会产生７层镜像，这样往往会使得镜像非常臃肿、非常多层，不仅增加了构建时间，还增大了出错概率。</p>
<p><strong>Union FS 是有最大层数限制的，比如 AUFS，是不得超过 127 层。</strong></p>
<p>像上面的情况，应该做命令合并，如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>FROM debian:stretch

RUN buildDeps=&#39;gcc libc6-dev make wget&#39; \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y $buildDeps \
    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \
    &amp;&amp; mkdir -p /usr/src/redis \
    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    &amp;&amp; make -C /usr/src/redis \
    &amp;&amp; make -C /usr/src/redis install \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r /usr/src/redis \
    &amp;&amp; apt-get purge -y --auto-remove $buildDeps
</pre></div>
</div>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
</li>
<li><p class="first">COPY</p>
<p><code class="docutils literal notranslate"><span class="pre">COPY</span></code>指令将构建上下文目录中的 <code class="docutils literal notranslate"><span class="pre">&lt;源路径&gt;</span></code>的文件/目录复制到新的一层的镜像内的 <code class="docutils literal notranslate"><span class="pre">&lt;目标路径&gt;</span></code>。格式为:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">COPY</span> <span class="p">[</span><span class="o">--</span><span class="n">chown</span><span class="o">=&lt;</span><span class="n">user</span><span class="o">&gt;</span><span class="p">:</span><span class="o">&lt;</span><span class="n">group</span><span class="o">&gt;</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">源路径</span><span class="o">&gt;...</span> <span class="o">&lt;</span><span class="n">目标路径</span><span class="o">&gt;</span>
</pre></div>
</div>
<blockquote>
<div><p>注意: 源文件一定是在构建上下文下，所以必须是相对路径。</p>
</div></blockquote>
<p>比如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">COPY</span> <span class="n">target</span><span class="o">/</span><span class="n">fp</span><span class="o">-</span><span class="n">frontend</span><span class="o">-</span><span class="mf">0.0</span><span class="o">.</span><span class="mf">1.</span><span class="n">jar</span> <span class="o">/</span><span class="n">app</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;源路径&gt;</span></code>可以是多个，甚至可以是通配符，例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>COPY hom* /mydir/
COPY hom?.txt /mydir/
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;目标路径&gt;</span></code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p>
<p>在使用该指令的时候还可以加上<code class="docutils literal notranslate"><span class="pre">--chown=&lt;user&gt;:&lt;group&gt;</span></code>选项来改变文件的所属用户及所属组。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">COPY</span> <span class="o">--</span><span class="n">chown</span><span class="o">=</span><span class="mi">55</span><span class="p">:</span><span class="n">mygroup</span> <span class="n">files</span><span class="o">*</span> <span class="o">/</span><span class="n">mydir</span><span class="o">/</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">chown</span><span class="o">=</span><span class="nb">bin</span> <span class="n">files</span><span class="o">*</span> <span class="o">/</span><span class="n">mydir</span><span class="o">/</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">chown</span><span class="o">=</span><span class="mi">1</span> <span class="n">files</span><span class="o">*</span> <span class="o">/</span><span class="n">mydir</span><span class="o">/</span>
<span class="n">COPY</span> <span class="o">--</span><span class="n">chown</span><span class="o">=</span><span class="mi">10</span><span class="p">:</span><span class="mi">11</span> <span class="n">files</span><span class="o">*</span> <span class="o">/</span><span class="n">mydir</span><span class="o">/</span>
</pre></div>
</div>
</li>
<li><p class="first">ADD</p>
<p><code class="docutils literal notranslate"><span class="pre">ADD</span></code> 指令和 <code class="docutils literal notranslate"><span class="pre">COPY</span></code> 的格式和性质基本一致。但是在 <code class="docutils literal notranslate"><span class="pre">COPY</span></code> 基础上增加了一些功能。</p>
<p>比如 <code class="docutils literal notranslate"><span class="pre">&lt;源路径&gt;</span></code> 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code class="docutils literal notranslate"><span class="pre">&lt;目标路径&gt;</span></code> 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 <code class="docutils literal notranslate"><span class="pre">RUN</span></code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code class="docutils literal notranslate"><span class="pre">RUN</span></code> 指令进行解压缩。所以不如直接使用 <code class="docutils literal notranslate"><span class="pre">RUN</span></code> 指令，然后使用 <code class="docutils literal notranslate"><span class="pre">wget</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">curl</span></code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">&lt;源路径&gt;</span></code> 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，<code class="docutils literal notranslate"><span class="pre">ADD</span></code> 指令将会自动解压缩这个压缩文件到 <code class="docutils literal notranslate"><span class="pre">&lt;目标路径&gt;</span></code> 去。</p>
<p><code class="docutils literal notranslate"><span class="pre">ADD</span></code>指令相比于<code class="docutils literal notranslate"><span class="pre">COPY</span></code>会包含更复杂的功能，但<code class="docutils literal notranslate"><span class="pre">COPY</span></code>的语义更明确，所以，尽可能使用<code class="docutils literal notranslate"><span class="pre">COPY</span></code>。<code class="docutils literal notranslate"><span class="pre">ADD</span></code>的最适合的场景，就是上述提及的需要自动解压的场合。另外需要注意的是，<code class="docutils literal notranslate"><span class="pre">ADD</span></code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>在使用该指令的时候还可以加上 <code class="docutils literal notranslate"><span class="pre">--chown=&lt;user&gt;:&lt;group&gt;</span></code> 选项来改变文件的所属用户及所属组。</p>
</li>
<li><p class="first">CMD</p>
<p><code class="docutils literal notranslate"><span class="pre">CMD</span></code>用来指定容器的启动命令，指令格式和<code class="docutils literal notranslate"><span class="pre">RUN</span></code>类似，有两种格式:</p>
<ul class="simple">
<li>shell格式: <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">&lt;命令&gt;</span></code></li>
<li>exec格式: <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">[&quot;可执行文件&quot;,</span> <span class="pre">&quot;参数1&quot;,</span> <span class="pre">&quot;参数2&quot;....]</span></code></li>
<li>参数列表格式: <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">[&quot;参数1&quot;,</span> <span class="pre">&quot;参数2&quot;...]</span></code>。在指定了 <code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 指令后，用<code class="docutils literal notranslate"><span class="pre">CMD</span></code> 指定具体的参数。</li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。在运行时可以指定新的命令来替代镜像设置中的这个默认命令。</p>
<p>在指令格式上，一般推荐使用 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code class="docutils literal notranslate"><span class="pre">&quot;</span></code>，而不要使用单引号。</p>
<p>如果使用 shell 格式的话，实际的命令会被包装为 <code class="docutils literal notranslate"><span class="pre">sh</span> <span class="pre">-c</span></code> 的参数的形式进行执行。比如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CMD echo $HOME
</pre></div>
</div>
<p>在实际执行中，会将其变更为：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CMD</span> <span class="p">[</span> <span class="s2">&quot;sh&quot;</span><span class="p">,</span> <span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;echo $HOME&quot;</span> <span class="p">]</span>
</pre></div>
</div>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>使用<code class="docutils literal notranslate"><span class="pre">CMD</span></code>，需要特别注意容器中应用在前台执行和后台执行的问题。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p>
<p>比如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CMD</span> <span class="n">service</span> <span class="n">nginx</span> <span class="n">start</span>
</pre></div>
</div>
<p>发现通过上述的方式启动nginx的化，在通过<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">run</span></code>启动容器时，执行完成后，容器就退出了。甚至在容器中使用<code class="docutils literal notranslate"><span class="pre">systemctl</span></code>命令结果却根本无法执行。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code class="docutils literal notranslate"><span class="pre">service</span> <span class="pre">nginx</span> <span class="pre">start</span></code> 命令，则是希望 <code class="docutils literal notranslate"><span class="pre">upstart</span></code> 来以后台守护进程形式启动 <code class="docutils literal notranslate"><span class="pre">nginx</span></code> 服务。而刚才说了 <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">service</span> <span class="pre">nginx</span> <span class="pre">start</span></code> 会被理解为 <code class="docutils literal notranslate"><span class="pre">CMD</span> <span class="pre">[</span> <span class="pre">&quot;sh&quot;,</span> <span class="pre">&quot;-c&quot;,</span> <span class="pre">&quot;service</span> <span class="pre">nginx</span> <span class="pre">start&quot;]</span></code>，因此主进程实际上是 sh。那么当 <code class="docutils literal notranslate"><span class="pre">service</span> <span class="pre">nginx</span> <span class="pre">start</span></code> 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;nginx&quot;</span><span class="p">,</span> <span class="s2">&quot;-g&quot;</span><span class="p">,</span> <span class="s2">&quot;daemon off;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">ENTRYPOINT</p>
<p><code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 的目的和 <code class="docutils literal notranslate"><span class="pre">CMD</span></code> 一样，都是在指定容器启动程序及参数。<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 在运行时也可以替代，不过比 <code class="docutils literal notranslate"><span class="pre">CMD</span></code> 要略显繁琐，需要通过 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code> 的参数<code class="docutils literal notranslate"><span class="pre">--entrypoint</span></code> 来指定。</p>
<p>当指定了 <code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 <code class="docutils literal notranslate"><span class="pre">CMD</span></code> 的内容作为参数传给 <code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 指令，换句话说实际执行时，将变为：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ENTRYPOINT</span><span class="o">&gt;</span> <span class="s2">&quot;&lt;CMD&gt;&quot;</span>
</pre></div>
</div>
<p>那相比于<code class="docutils literal notranslate"><span class="pre">CMD</span></code>，<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>有什么好处呢？</p>
<ul class="simple">
<li>场景一: 让镜像变得像命令一样使用
假设我们需要一个得知自己当前公网IP的镜像，用<code class="docutils literal notranslate"><span class="pre">CMD</span></code>实现:</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">18.04</span>
<span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> \
    <span class="o">&amp;&amp;</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">curl</span> \
    <span class="o">&amp;&amp;</span> <span class="n">rm</span> <span class="o">-</span><span class="n">rf</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">apt</span><span class="o">/</span><span class="n">lists</span><span class="o">/*</span>
<span class="n">CMD</span> <span class="p">[</span> <span class="s2">&quot;curl&quot;</span><span class="p">,</span> <span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="s2">&quot;https://ip.cn&quot;</span> <span class="p">]</span>
</pre></div>
</div>
<p>执行<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-t</span> <span class="pre">myip:0.1</span> <span class="pre">.</span></code>构建镜像。如果需要查询当前公网IP，只需要执行:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">run</span> <span class="n">myip</span><span class="p">:</span><span class="mf">0.1</span>
</pre></div>
</div>
<p>就可以得到如下结果:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">当前</span> <span class="n">IP</span><span class="p">:</span> <span class="mf">103.59</span><span class="o">.</span><span class="mf">48.21</span> <span class="n">来自</span><span class="p">:</span> <span class="n">香港特别行政区</span>
</pre></div>
</div>
<p>但，在启动时传递参数时，如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">run</span> <span class="n">myip</span><span class="p">:</span><span class="mf">0.1</span> <span class="o">-</span><span class="n">i</span>
</pre></div>
</div>
<p>结果却是:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">container_linux</span><span class="o">.</span><span class="n">go</span><span class="p">:</span><span class="mi">247</span><span class="p">:</span> <span class="n">starting</span> <span class="n">container</span> <span class="n">process</span> <span class="n">caused</span> <span class="s2">&quot;exec: </span><span class="se">\&quot;</span><span class="s2">-i</span><span class="se">\&quot;</span><span class="s2">: executable file not found in $PATH&quot;</span>
<span class="n">docker</span><span class="p">:</span> <span class="n">Error</span> <span class="n">response</span> <span class="kn">from</span> <span class="nn">daemon</span><span class="p">:</span> <span class="n">oci</span> <span class="n">runtime</span> <span class="n">error</span><span class="p">:</span> <span class="n">container_linux</span><span class="o">.</span><span class="n">go</span><span class="p">:</span><span class="mi">247</span><span class="p">:</span> <span class="n">starting</span> <span class="n">container</span> <span class="n">process</span> <span class="n">caused</span> <span class="s2">&quot;exec: </span><span class="se">\&quot;</span><span class="s2">-i</span><span class="se">\&quot;</span><span class="s2">: executable file not found in $PATH&quot;</span><span class="o">.</span>
<span class="n">ERRO</span><span class="p">[</span><span class="mi">0000</span><span class="p">]</span> <span class="n">error</span> <span class="n">getting</span> <span class="n">events</span> <span class="kn">from</span> <span class="nn">daemon</span><span class="p">:</span> <span class="n">net</span><span class="o">/</span><span class="n">http</span><span class="p">:</span> <span class="n">request</span> <span class="n">canceled</span>
</pre></div>
</div>
<p>之前说过，如果是<code class="docutils literal notranslate"><span class="pre">CMD</span></code>，启动容器时传递的参数，会替换<code class="docutils literal notranslate"><span class="pre">CMD</span></code>的默认值，也就是上述执行的是<code class="docutils literal notranslate"><span class="pre">sh</span> <span class="pre">-c</span> <span class="pre">-i</span></code>，并不是预期的<code class="docutils literal notranslate"><span class="pre">sh</span> <span class="pre">-c</span> <span class="pre">curl</span> <span class="pre">-s</span> <span class="pre">https://ip.cn</span> <span class="pre">-i</span></code>。</p>
<p>而使用<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>就可以解决这个问题，可以将上述<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>中<code class="docutils literal notranslate"><span class="pre">CMD</span></code>替换成<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>，重新构建，验证下。</p>
<ul class="simple">
<li>场景二: 应用运行前的准备工作</li>
</ul>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如，在实际场景中，会避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。</p>
<p>这些预备动作，就可以写一个脚本，然后放到<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>中去执行，而把脚本将要接收到的参数(即<code class="docutils literal notranslate"><span class="pre">CMD</span></code>指定的命令)作为命令，在脚本最后执行。例如，官网的<code class="docutils literal notranslate"><span class="pre">redis</span></code> 镜像就是这么做的:</p>
<p>Dockerfile:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">alpine</span><span class="p">:</span><span class="mf">3.4</span>
<span class="o">...</span>
<span class="n">RUN</span> <span class="n">addgroup</span> <span class="o">-</span><span class="n">S</span> <span class="n">redis</span> <span class="o">&amp;&amp;</span> <span class="n">adduser</span> <span class="o">-</span><span class="n">S</span> <span class="o">-</span><span class="n">G</span> <span class="n">redis</span> <span class="n">redis</span>
<span class="o">...</span>
<span class="n">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&quot;docker-entrypoint.sh&quot;</span><span class="p">]</span>

<span class="n">EXPOSE</span> <span class="mi">6379</span>
<span class="n">CMD</span> <span class="p">[</span> <span class="s2">&quot;redis-server&quot;</span> <span class="p">]</span>
</pre></div>
</div>
<p>docker-entrypoint.sh:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="o">...</span>
<span class="c1"># allow the container to be started with `--user`</span>
<span class="k">if</span> <span class="p">[</span> <span class="s2">&quot;$1&quot;</span> <span class="o">=</span> <span class="s1">&#39;redis-server&#39;</span> <span class="o">-</span><span class="n">a</span> <span class="s2">&quot;$(id -u)&quot;</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span> <span class="p">];</span> <span class="n">then</span>
    <span class="n">chown</span> <span class="o">-</span><span class="n">R</span> <span class="n">redis</span> <span class="o">.</span>
    <span class="n">exec</span> <span class="n">su</span><span class="o">-</span><span class="n">exec</span> <span class="n">redis</span> <span class="s2">&quot;$0&quot;</span> <span class="s2">&quot;$@&quot;</span>
<span class="n">fi</span>

<span class="n">exec</span> <span class="s2">&quot;$@&quot;</span>
</pre></div>
</div>
<p>脚本的内容是根据传入的参数(即<code class="docutils literal notranslate"><span class="pre">CMD</span></code>指定的)来判断，如果是<code class="docutils literal notranslate"><span class="pre">redis-server</span></code>，则切换到<code class="docutils literal notranslate"><span class="pre">redis</span></code>用户下执行启动服务器；否则以<code class="docutils literal notranslate"><span class="pre">root</span></code>用户，执行<code class="docutils literal notranslate"><span class="pre">CMD</span></code>指定的命令。</p>
<p>那么，如果是<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">run</span> <span class="pre">-it</span> <span class="pre">redis</span> <span class="pre">id</span></code>，<code class="docutils literal notranslate"><span class="pre">CMD</span></code>被替换为<code class="docutils literal notranslate"><span class="pre">id</span></code>，会使用<code class="docutils literal notranslate"><span class="pre">root</span></code>用户执行<code class="docutils literal notranslate"><span class="pre">id</span></code>命令，输出如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uid</span><span class="o">=</span><span class="mi">0</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">gid</span><span class="o">=</span><span class="mi">0</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="n">groups</span><span class="o">=</span><span class="mi">0</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">ENV</p>
<p><code class="docutils literal notranslate"><span class="pre">ENV</span></code>用来设置环境变量。格式为:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ENV</span> <span class="pre">&lt;key&gt;</span> <span class="pre">&lt;value&gt;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">ENV</span> <span class="pre">&lt;key1&gt;=&lt;value1&gt;</span> <span class="pre">&lt;key2&gt;=&lt;value2&gt;...</span></code></li>
</ul>
<p>设置环境变量后，在<code class="docutils literal notranslate"><span class="pre">ENV</span></code>后续的指令，或者运行时的应用，都可以使用该环境变量。</p>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>FROM ubuntu:14.04
ENV profile=test
RUN echo $profile
</pre></div>
</div>
<p>执行构建<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-t</span> <span class="pre">env-test:0.1</span> <span class="pre">.</span></code>，构建中会输出<code class="docutils literal notranslate"><span class="pre">test</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Sending build context to Docker daemon 514.6 kB
Step 1/3 : FROM ubuntu:14.04
 ---&gt; 5dbc3f318ea5
Step 2/3 : ENV profile test
 ---&gt; Running in 9c4971f4c0e7
 ---&gt; 172ff378ada8
Removing intermediate container 9c4971f4c0e7
Step 3/3 : RUN echo $profile
 ---&gt; Running in 7e6cde357417
test
 ---&gt; 6c93c2ef1e4b
Removing intermediate container 7e6cde357417
Successfully built 6c93c2ef1e4b
</pre></div>
</div>
<p>通过交互方式进入容器<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">run</span> <span class="pre">-ti</span> <span class="pre">env-test:0.1</span> <span class="pre">bash</span></code>，执行:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@57bd9be6fb61</span><span class="p">:</span><span class="o">/</span><span class="c1"># echo $profile</span>
<span class="n">test</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ENV</span></code>也可以用来作为可变参数，比如官网的<code class="docutils literal notranslate"><span class="pre">node</span></code>镜像:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ENV</span> <span class="n">NODE_VERSION</span> <span class="mf">7.2</span><span class="o">.</span><span class="mi">0</span>

<span class="n">RUN</span> <span class="n">curl</span> <span class="o">-</span><span class="n">SLO</span> <span class="s2">&quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;</span> \
  <span class="o">&amp;&amp;</span> <span class="n">curl</span> <span class="o">-</span><span class="n">SLO</span> <span class="s2">&quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</span> \
  <span class="o">&amp;&amp;</span> <span class="n">gpg</span> <span class="o">--</span><span class="n">batch</span> <span class="o">--</span><span class="n">decrypt</span> <span class="o">--</span><span class="n">output</span> <span class="n">SHASUMS256</span><span class="o">.</span><span class="n">txt</span> <span class="n">SHASUMS256</span><span class="o">.</span><span class="n">txt</span><span class="o">.</span><span class="n">asc</span> \
  <span class="o">&amp;&amp;</span> <span class="n">grep</span> <span class="s2">&quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot;</span> <span class="n">SHASUMS256</span><span class="o">.</span><span class="n">txt</span> <span class="o">|</span> <span class="n">sha256sum</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span> \
  <span class="o">&amp;&amp;</span> <span class="n">tar</span> <span class="o">-</span><span class="n">xJf</span> <span class="s2">&quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot;</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span> <span class="o">--</span><span class="n">strip</span><span class="o">-</span><span class="n">components</span><span class="o">=</span><span class="mi">1</span> \
  <span class="o">&amp;&amp;</span> <span class="n">rm</span> <span class="s2">&quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot;</span> <span class="n">SHASUMS256</span><span class="o">.</span><span class="n">txt</span><span class="o">.</span><span class="n">asc</span> <span class="n">SHASUMS256</span><span class="o">.</span><span class="n">txt</span> \
  <span class="o">&amp;&amp;</span> <span class="n">ln</span> <span class="o">-</span><span class="n">s</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">node</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">nodejs</span>
</pre></div>
</div>
<p>这样，在后续版本需要变更时，只需更改<code class="docutils literal notranslate"><span class="pre">NODE_VERSION</span></code>环境变量即可。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。</p>
</li>
<li><p class="first">ARG</p>
<p><code class="docutils literal notranslate"><span class="pre">ARG</span></code>用来指定构建参数。格式为:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ARG</span> <span class="pre">&lt;参数名&gt;[=&lt;默认值&gt;]</span></code></li>
</ul>
<p>构建参数和 <code class="docutils literal notranslate"><span class="pre">ENV</span></code> 的效果一样，都是设置环境变量。所不同的是，<code class="docutils literal notranslate"><span class="pre">ARG</span></code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code class="docutils literal notranslate"><span class="pre">ARG</span></code> 保存密码之类的信息，因为 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">history</span></code> 还是可以看到所有值的。</p>
<p><code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">ARG</span></code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code> 中用 <code class="docutils literal notranslate"><span class="pre">--build-arg</span> <span class="pre">&lt;参数名&gt;=&lt;值&gt;</span></code> 来覆盖。</p>
</li>
<li><p class="first">VOLUME</p>
<p><code class="docutils literal notranslate"><span class="pre">VOLUME</span></code>用来定义匿名卷，格式为:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">VOLUME</span> <span class="pre">[&quot;&lt;路径1&gt;&quot;,</span> <span class="pre">&quot;&lt;路径2&gt;&quot;...]</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">VOLUME</span> <span class="pre">&lt;路径&gt;</span></code></li>
</ul>
<p>按照最佳实践，在容器运行时，应尽量保持容器存储层不发生写操作，对需要保存的数据，应该保存在卷(<code class="docutils literal notranslate"><span class="pre">volume</span></code>)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VOLUME</span> <span class="o">/</span><span class="n">data</span>
</pre></div>
</div>
<p>这里的 <code class="docutils literal notranslate"><span class="pre">/data</span></code> 目录就会在运行时自动挂载为匿名卷，任何向 <code class="docutils literal notranslate"><span class="pre">/data</span></code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。</p>
<p>匿名卷是指在启动容器时，随容器启动而创建，随着容器消亡而淹没于卷列表中（对于 docker run 匿名卷不会被自动删除。</p>
<p>通过<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">volume</span> <span class="pre">ls</span></code>可查看创建的卷。输出如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DRIVER</span>              <span class="n">VOLUME</span> <span class="n">NAME</span>
<span class="n">local</span>               <span class="mi">002</span><span class="n">ca4875224a327f6874010974f00395922a210078ae36a5193fc049dfc5c1b</span>
<span class="n">local</span>               <span class="mf">020e077156</span><span class="n">ea401e510542c85fdd196c23cbaff97df3a26b0ead23ba7c49d85a</span>
<span class="n">local</span>               <span class="n">service_mariadb_data</span>
<span class="n">local</span>               <span class="n">service_testlink_data</span>
</pre></div>
</div>
<p>像<code class="docutils literal notranslate"><span class="pre">002ca4875224a327f6874010974f00395922a210078ae36a5193fc049dfc5c1b</span></code>即是匿名卷，通过<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">inspect</span> <span class="pre">002ca4875224a327f6874010974f00395922a210078ae36a5193fc049dfc5c1b</span></code>查看详情，如下“</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">&quot;Driver&quot;</span><span class="p">:</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Labels&quot;</span><span class="p">:</span> <span class="n">null</span><span class="p">,</span>
        <span class="s2">&quot;Mountpoint&quot;</span><span class="p">:</span> <span class="s2">&quot;/var/lib/docker/volumes/002ca4875224a327f6874010974f00395922a210078ae36a5193fc049dfc5c1b/_data&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Name&quot;</span><span class="p">:</span> <span class="s2">&quot;002ca4875224a327f6874010974f00395922a210078ae36a5193fc049dfc5c1b&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Options&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;Scope&quot;</span><span class="p">:</span> <span class="s2">&quot;local&quot;</span>
    <span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
<p>当然，运行时可以覆盖这个挂载设置，如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">-</span><span class="n">v</span> <span class="n">mydata</span><span class="p">:</span><span class="o">/</span><span class="n">data</span> <span class="n">xxxx</span>
</pre></div>
</div>
<p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。
上述查询卷列表中的<code class="docutils literal notranslate"><span class="pre">service_mariadb_data</span></code>既是此类。</p>
</li>
<li><p class="first">EXPOSE</p>
<p><code class="docutils literal notranslate"><span class="pre">EXPOSE</span></code>用来声明端口，格式为:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">EXPOSE</span> <span class="pre">&lt;端口1&gt;</span> <span class="pre">[&lt;端口2&gt;...]</span></code></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">EXPOSE</span></code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">-P</span></code> 时，会自动随机映射 <code class="docutils literal notranslate"><span class="pre">EXPOSE</span></code> 的端口。</p>
<p>要将 <code class="docutils literal notranslate"><span class="pre">EXPOSE</span></code> 和在运行时使用 <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">&lt;宿主端口&gt;:&lt;容器端口&gt;</span></code> 区分开来。<code class="docutils literal notranslate"><span class="pre">-p</span></code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code class="docutils literal notranslate"><span class="pre">EXPOSE</span></code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
</li>
<li><p class="first">WORKDIR</p>
<p><code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code>用来指定工作目录，格式为:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">WORKDIR</span> <span class="pre">&lt;工作目录路径&gt;</span></code></li>
</ul>
<p>使用 <code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code> 会帮你建立目录。</p>
<p>有些常犯的错误是把 <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="n">cd</span> <span class="o">/</span><span class="n">app</span>
<span class="n">RUN</span> <span class="n">echo</span> <span class="s2">&quot;hello&quot;</span> <span class="o">&gt;</span> <span class="n">world</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 <code class="docutils literal notranslate"><span class="pre">/app/world.txt</span></code> 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code class="docutils literal notranslate"><span class="pre">RUN</span></code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">cd</span> <span class="pre">/app</span></code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code> 指令。</p>
</li>
<li><p class="first">USER</p>
<p><code class="docutils literal notranslate"><span class="pre">USER</span></code>用来指定当前用户，格式为:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">USER</span> <span class="pre">&lt;用户名&gt;[:&lt;用户组&gt;]</span></code></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">USER</span></code> 指令和 <code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code> 相似，都是改变环境状态并影响以后的层。<code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code> 是改变工作目录，<code class="docutils literal notranslate"><span class="pre">USER</span></code> 则是改变之后层的执行 <code class="docutils literal notranslate"><span class="pre">RUN</span></code>, <code class="docutils literal notranslate"><span class="pre">CMD</span></code> 以及<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 这类命令的身份。</p>
<p>当然，<code class="docutils literal notranslate"><span class="pre">USER</span></code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="n">groupadd</span> <span class="o">-</span><span class="n">r</span> <span class="n">redis</span> <span class="o">&amp;&amp;</span> <span class="n">useradd</span> <span class="o">-</span><span class="n">r</span> <span class="o">-</span><span class="n">g</span> <span class="n">redis</span> <span class="n">redis</span>
<span class="n">USER</span> <span class="n">redis</span>
<span class="n">RUN</span> <span class="p">[</span> <span class="s2">&quot;redis-server&quot;</span> <span class="p">]</span>
</pre></div>
</div>
<p>如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a class="reference external" href="https://github.com/tianon/gosu">gosu</a>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span>
<span class="n">RUN</span> <span class="n">groupadd</span> <span class="o">-</span><span class="n">r</span> <span class="n">redis</span> <span class="o">&amp;&amp;</span> <span class="n">useradd</span> <span class="o">-</span><span class="n">r</span> <span class="o">-</span><span class="n">g</span> <span class="n">redis</span> <span class="n">redis</span>
<span class="c1"># 下载 gosu</span>
<span class="n">RUN</span> <span class="n">wget</span> <span class="o">-</span><span class="n">O</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">gosu</span> <span class="s2">&quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot;</span> \
    <span class="o">&amp;&amp;</span> <span class="n">chmod</span> <span class="o">+</span><span class="n">x</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">gosu</span> \
    <span class="o">&amp;&amp;</span> <span class="n">gosu</span> <span class="n">nobody</span> <span class="n">true</span>
<span class="c1"># 设置 CMD，并以另外的用户执行</span>
<span class="n">CMD</span> <span class="p">[</span> <span class="s2">&quot;exec&quot;</span><span class="p">,</span> <span class="s2">&quot;gosu&quot;</span><span class="p">,</span> <span class="s2">&quot;redis&quot;</span><span class="p">,</span> <span class="s2">&quot;redis-server&quot;</span> <span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">HEALTHCHECK</p>
<p><code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span></code>用来提供容器内应用进程健康状态检测。
Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了</p>
<p>格式为:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">[选项]</span> <span class="pre">CMD</span> <span class="pre">&lt;命令&gt;</span></code>：设置检查容器健康状况的命令
*<code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">NONE</span></code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span></code>支持下列选项:</p>
<ul class="simple">
<li>--interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒；</li>
<li>--timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li>--retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。</li>
</ul>
<p>和 <code class="docutils literal notranslate"><span class="pre">CMD</span></code>, <code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 一样，<code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span></code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">[选项]</span> <span class="pre">CMD</span></code> 后面的命令，格式和 <code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 一样，分为 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 格式，和 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。</p>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">nginx</span>
<span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">&amp;&amp;</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">curl</span> <span class="o">&amp;&amp;</span> <span class="n">rm</span> <span class="o">-</span><span class="n">rf</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">apt</span><span class="o">/</span><span class="n">lists</span><span class="o">/*</span>
<span class="n">HEALTHCHECK</span> <span class="o">--</span><span class="n">interval</span><span class="o">=</span><span class="mi">5</span><span class="n">s</span> <span class="o">--</span><span class="n">timeout</span><span class="o">=</span><span class="mi">3</span><span class="n">s</span> \
  <span class="n">CMD</span> <span class="n">curl</span> <span class="o">-</span><span class="n">fs</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">localhost</span><span class="o">/</span> <span class="o">||</span> <span class="n">exit</span> <span class="mi">1</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id9">
<h4>4.3.1.4. 构建镜像<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>下面以<code class="docutils literal notranslate"><span class="pre">fp-frontend</span></code>为例，介绍如何编写<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>，构建镜像。</p>
<ul class="simple">
<li>编译打包</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 工程跟目录</span>
<span class="n">cd</span> <span class="n">fp</span><span class="o">-</span><span class="n">frontend</span>

<span class="c1">## 编译</span>
<span class="n">mvn</span> <span class="n">clean</span> <span class="n">package</span> <span class="o">-</span><span class="n">Dmaven</span><span class="o">.</span><span class="n">test</span><span class="o">.</span><span class="n">skip</span><span class="o">=</span><span class="n">true</span>
</pre></div>
</div>
<p>编译完成后，在<code class="docutils literal notranslate"><span class="pre">target/fp-frontend-0.0.1-SNAPSHOT.jar</span></code>即是所需的运行包。</p>
<ul class="simple">
<li>在工程根目录下创建<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>文件</li>
</ul>
<p>如果按上述步骤操作，可清空<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>文件，或者删除重建。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 工程根目录</span>
<span class="n">cd</span> <span class="n">fp</span><span class="o">-</span><span class="n">frontend</span>
<span class="c1">## 创建Dockerfile文件</span>
<span class="n">touch</span> <span class="n">Dockerfile</span>
</pre></div>
</div>
<ul class="simple">
<li>增加基础镜像</li>
</ul>
<p>由于是<code class="docutils literal notranslate"><span class="pre">java</span></code>工程，引入的基础镜像是<code class="docutils literal notranslate"><span class="pre">openjdk:8-jre</span></code>(基础镜像要尽量收拢，稳定，以及尽量小。这里选用jre，而非jdk)。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 编辑Dockerfile</span>
<span class="n">vi</span> <span class="n">Dockerfile</span>

<span class="c1">## 增加基础镜像</span>
<span class="n">FROM</span> <span class="n">openjdk</span><span class="p">:</span><span class="mi">8</span><span class="o">-</span><span class="n">jre</span>
</pre></div>
</div>
<ul class="simple">
<li>创建用户</li>
</ul>
<p>按照<a class="reference external" href="https://confluence.yitu-inc.com/pages/viewpage.action?pageId=307495610">容器化规范</a>要求，需要在Dockerfile中定义非root用户，以该用户运行应用，uid要在5000-5100范围内。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>## 用户UID
ARG UID=5000

## 创建用户组
RUN groupadd -r fp

## 创建用户
RUN useradd -r -u $UID -g fp fp

## 使用gosu来切换用户，参考上述USER指令中的介绍
RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.10/gosu-amd64&quot;
RUN chmod +x /usr/local/bin/gosu &amp;&amp; gosu nobody true
</pre></div>
</div>
<ul class="simple">
<li>创建挂载卷</li>
</ul>
<p>在示例应用中，会将日志输出到文件中，日志目录是通过<code class="docutils literal notranslate"><span class="pre">LOG_HOME</span></code>环境变量设置的，具体参考源码中的<a class="reference external" href="http://gitlab.yitu-inc.com/devops/observability/fp-frontend/blob/master/src/main/resources/logback.xml">logback.xml</a>。</p>
<p>所以，这里会用到两个指令--ENV和VOLUME:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 设置环境变量</span>
<span class="n">ENV</span> <span class="n">LOG_HOME</span><span class="o">=/</span><span class="n">logs</span>

<span class="c1">## 创建日志目录</span>
<span class="n">RUN</span> <span class="n">mkdir</span> <span class="o">/</span><span class="n">logs</span>

<span class="c1">## 容器中默认的执行用户是root，而应用是用非root用户(即之前创建的fp用户)运行的，这里需要切换/logs目录属主</span>
<span class="n">RUN</span> <span class="n">chown</span> <span class="n">fp</span><span class="p">:</span><span class="n">fp</span> <span class="o">/</span><span class="n">logs</span>

<span class="c1">## 创建匿名卷，注意: VOLUME指令一定是要在最后，具体参考: VOLUME机制</span>
<span class="n">VOLUME</span> <span class="o">/</span><span class="n">logs</span>
</pre></div>
</div>
<ul class="simple">
<li>配置运行程序</li>
</ul>
<p>规划应用的运行目录为<code class="docutils literal notranslate"><span class="pre">/app</span></code>，应用程序是之前编译输出的<code class="docutils literal notranslate"><span class="pre">target/fp-frontend-0.0.1-SNAPSHOT.jar</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 设置工作目录，目录不存在，WORKDIR会自动创建</span>
<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">app</span>

<span class="c1">## 将应用程序从主机上拷贝至容器的/app目录下</span>
<span class="n">COPY</span> <span class="n">target</span><span class="o">/</span><span class="n">fp</span><span class="o">-</span><span class="n">frontend</span><span class="o">-</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span><span class="o">-</span><span class="n">SNAPSHOT</span><span class="o">.</span><span class="n">jar</span> <span class="o">/</span><span class="n">app</span>
</pre></div>
</div>
<ul class="simple">
<li>暴露端口</li>
</ul>
<p>应用对外提供HTTP服务，暴露8081端口，具体参考源码中的<a class="reference external" href="http://gitlab.yitu-inc.com/devops/observability/fp-frontend/blob/master/src/main/resources/application-dev.yml">application-dev.yml</a>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 暴露端口</span>
<span class="n">EXPOSE</span> <span class="mi">8081</span>
</pre></div>
</div>
<ul class="simple">
<li>设置应用启动命令</li>
</ul>
<p>由于是<code class="docutils literal notranslate"><span class="pre">spring</span> <span class="pre">boot</span></code>应用，编译输出的是<code class="docutils literal notranslate"><span class="pre">fat</span> <span class="pre">jar</span></code>，直接运行jar包即可运行。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 设置启动命令</span>
<span class="n">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&quot;gosu&quot;</span><span class="p">,</span> <span class="s2">&quot;fp&quot;</span><span class="p">,</span> <span class="s2">&quot;java&quot;</span><span class="p">,</span> <span class="s2">&quot;-jar&quot;</span><span class="p">,</span> <span class="s2">&quot;fp-frontend-0.0.1-SNAPSHOT.jar&quot;</span><span class="p">]</span>
</pre></div>
</div>
<ul>
<li><p class="first">优化</p>
<p>按照我们之前的介绍，需要把Dockerfile做个优化:</p>
<ul class="simple">
<li>把版本信息以环境变量(ENV)或者ARG(变量)的形式定义</li>
<li>将RUN指令合并(注意执行顺序)</li>
</ul>
<p>保存Dockerfile。
优化后的Dockerfile参考<a class="reference external" href="http://gitlab.yitu-inc.com/devops/observability/fp-frontend/tree/docker-0.1/">docker-0.1</a>分支。</p>
</li>
<li><p class="first">构建</p>
</li>
</ul>
<p>构建镜像，镜像名称为<code class="docutils literal notranslate"><span class="pre">fp/frontend</span></code>，tag为<code class="docutils literal notranslate"><span class="pre">0.0.1</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 在工程根目录下执行</span>
<span class="n">sudo</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">fp</span><span class="o">/</span><span class="n">frontend</span><span class="p">:</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span> <span class="o">.</span>
</pre></div>
</div>
<p>构建完成后，执行<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">images</span></code>查看镜像。</p>
<blockquote>
<div>注意: 构建过程中需要下载gosu，保证能够连接外网，如果下载失败，重试。</div></blockquote>
<ul class="simple">
<li>验证</li>
</ul>
<p>构建完成镜像后，启动容器验证下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 运行容器</span>
<span class="n">sudo</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="n">fp</span><span class="o">/</span><span class="n">frontend</span><span class="p">:</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span>
</pre></div>
</div>
<p>查看容器状态: <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">ps</span> <span class="pre">-a</span></code>，输出如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CONTAINER</span> <span class="n">ID</span>        <span class="n">IMAGE</span>               <span class="n">COMMAND</span>                  <span class="n">CREATED</span>             <span class="n">STATUS</span>              <span class="n">PORTS</span>                               <span class="n">NAMES</span>
<span class="n">ff0474afd136</span>        <span class="n">fp</span><span class="o">/</span><span class="n">frontend</span><span class="p">:</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span>   <span class="s2">&quot;gosu fp java -jar...&quot;</span>   <span class="mi">53</span> <span class="n">seconds</span> <span class="n">ago</span>      <span class="n">Up</span> <span class="mi">52</span> <span class="n">seconds</span>       <span class="mi">8081</span><span class="o">/</span><span class="n">tcp</span>                            <span class="n">sad_volhard</span>
</pre></div>
</div>
<p>容器状态应为<code class="docutils literal notranslate"><span class="pre">Up</span></code>。</p>
<p>查看容器日志:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">logs</span> <span class="n">ff0474afd136</span>
</pre></div>
</div>
<ul class="simple">
<li>VOLUME机制</li>
</ul>
<p>在编写Dockerfile时，提到应用会将日志输出到文件，所以创建了挂载卷(/logs)。上述运行容器时，并没有通过<code class="docutils literal notranslate"><span class="pre">-v</span></code>指定挂载卷。这时，docker会默认创建个挂载卷，这就是所谓的<code class="docutils literal notranslate"><span class="pre">匿名卷</span></code>。</p>
<p>执行<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">inspect</span> <span class="pre">ff0474afd136</span> <span class="pre">|</span> <span class="pre">grep</span> <span class="pre">-A</span> <span class="pre">10</span> <span class="pre">Mounts</span></code>查看挂载卷信息，如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;Mounts&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s2">&quot;Type&quot;</span><span class="p">:</span> <span class="s2">&quot;volume&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Name&quot;</span><span class="p">:</span> <span class="s2">&quot;6b00a9e75314367e71c63e408b1bb27c6bf9cc2ec537153e452104671a47a36c&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Source&quot;</span><span class="p">:</span> <span class="s2">&quot;/var/lib/docker/volumes/6b00a9e75314367e71c63e408b1bb27c6bf9cc2ec537153e452104671a47a36c/_data&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Destination&quot;</span><span class="p">:</span> <span class="s2">&quot;/logs&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Driver&quot;</span><span class="p">:</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Mode&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;RW&quot;</span><span class="p">:</span> <span class="n">true</span><span class="p">,</span>
                <span class="s2">&quot;Propagation&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span>
            <span class="p">}</span>
</pre></div>
</div>
<p>可以看到主机上的挂载卷是在<code class="docutils literal notranslate"><span class="pre">/var/lib/docker/volumes/6b00a9e75314367e71c63e408b1bb27c6bf9cc2ec537153e452104671a47a36c/_data</span></code>目录下，查看该目录，应有<code class="docutils literal notranslate"><span class="pre">debug-log.log</span></code>文件(注意，需使用root用户)。</p>
<p>前面提到，可以使用<code class="docutils literal notranslate"><span class="pre">-v</span></code>命令指定主机挂载卷，如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sudo docker run -d -v $PWD/logs:/logs fp/frontend:0.0.1
</pre></div>
</div>
<p>这里是将当前目录下的<code class="docutils literal notranslate"><span class="pre">logs</span></code>目录作为挂载卷。这时，会有两种情况:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>* 如果本地logs目录不存在，则docker会自动创建，目录的权限为运行docker的用户(示例中为root)
* 如果本地logs目录存在，则docker以本地目录创建挂载卷。
</pre></div>
</div>
<p>下面说下第二种情况。在本地logs目录存在的情况下，docker的原则是不能删除本地文件，所以，会以本地文件的信息创建挂载卷(包括目录的属主，权限，目录下的内容)。
通过<code class="docutils literal notranslate"><span class="pre">-v</span></code>命令， 就会使用定义的命名卷(<code class="docutils literal notranslate"><span class="pre">$PWD/logs</span></code>)挂载到容器<code class="docutils literal notranslate"><span class="pre">/logs</span></code>目录，替代Dockerfile中定义的匿名卷的挂载位置。也就是说，在容器中操作/logs目录，就等同于操作主机上的<code class="docutils literal notranslate"><span class="pre">$PWD/logs</span></code>目录。</p>
<p>这里就可能会存在一个问题，由于容器中是以<code class="docutils literal notranslate"><span class="pre">fp</span></code>用户运行的，而本地的<code class="docutils literal notranslate"><span class="pre">$PWD/logs</span></code>目录的属主可能与容器中的<code class="docutils literal notranslate"><span class="pre">fp</span></code>不一致(其实是uid不一致)。启动时就会报错，如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">04</span><span class="p">:</span><span class="mi">04</span><span class="p">:</span><span class="mi">06</span><span class="p">,</span><span class="mi">681</span> <span class="o">|-</span><span class="n">ERROR</span> <span class="ow">in</span> <span class="n">ch</span><span class="o">.</span><span class="n">qos</span><span class="o">.</span><span class="n">logback</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">rolling</span><span class="o">.</span><span class="n">RollingFileAppender</span><span class="p">[</span><span class="n">FILE</span><span class="p">]</span> <span class="o">-</span> <span class="n">openFile</span><span class="p">(</span><span class="o">/</span><span class="n">logs</span><span class="o">/</span><span class="n">debug</span><span class="o">-</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">,</span><span class="n">true</span><span class="p">)</span> <span class="n">call</span> <span class="n">failed</span><span class="o">.</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">FileNotFoundException</span><span class="p">:</span> <span class="o">/</span><span class="n">logs</span><span class="o">/</span><span class="n">debug</span><span class="o">-</span><span class="n">log</span><span class="o">.</span><span class="n">log</span> <span class="p">(</span><span class="n">Permission</span> <span class="n">denied</span><span class="p">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">FileNotFoundException</span><span class="p">:</span> <span class="o">/</span><span class="n">logs</span><span class="o">/</span><span class="n">debug</span><span class="o">-</span><span class="n">log</span><span class="o">.</span><span class="n">log</span> <span class="p">(</span><span class="n">Permission</span> <span class="n">denied</span><span class="p">)</span>
	<span class="n">at</span> 	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">FileOutputStream</span><span class="o">.</span><span class="n">open0</span><span class="p">(</span><span class="n">Native</span> <span class="n">Method</span><span class="p">)</span>
	<span class="n">at</span> 	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">FileOutputStream</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">FileOutputStream</span><span class="o">.</span><span class="n">java</span><span class="p">:</span><span class="mi">270</span><span class="p">)</span>
	<span class="n">at</span> 	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">FileOutputStream</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;</span><span class="p">(</span><span class="n">FileOutputStream</span><span class="o">.</span><span class="n">java</span><span class="p">:</span><span class="mi">213</span><span class="p">)</span>
	<span class="n">at</span> 	<span class="n">at</span> <span class="n">ch</span><span class="o">.</span><span class="n">qos</span><span class="o">.</span><span class="n">logback</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">recovery</span><span class="o">.</span><span class="n">ResilientFileOutputStream</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ResilientFileOutputStream</span><span class="o">.</span><span class="n">java</span><span class="p">:</span><span class="mi">26</span><span class="p">)</span>
</pre></div>
</div>
<p>注: 可以将Dockerfile中的<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>改成<code class="docutils literal notranslate"><span class="pre">CMD</span></code>，然后重新构建镜像，以交互的方式进入容器<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">run</span> <span class="pre">-ti</span> <span class="pre">-v</span> <span class="pre">$PWD/logs:/logs</span> <span class="pre">fp/frontend:0.0.1</span> <span class="pre">bash</span></code>，查看<code class="docutils literal notranslate"><span class="pre">/logs</span></code>的属主信息。</p>
<ul class="simple">
<li>如何解决？</li>
</ul>
<p>除了上述VOLUME的问题外，还有个问题。</p>
<p>在Dockerfile中指定启动命令中<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span> <span class="pre">[&quot;gosu&quot;,</span> <span class="pre">&quot;fp&quot;,</span> <span class="pre">&quot;java&quot;,</span> <span class="pre">&quot;-jar&quot;,</span> <span class="pre">&quot;fp-frontend-0.0.1-SNAPSHOT.jar&quot;]</span></code>，并没有使用<code class="docutils literal notranslate"><span class="pre">APP_VERSION</span></code>环境变量。这时因为，这里是把<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>当做字符串解析的，无法使用环境变量。
基于此，可以将启动命令以脚本的形式体现。在启动脚本中，设置挂载卷的属主权限；并可以使用环境变量。</p>
<p>在工程根目录下增加<code class="docutils literal notranslate"><span class="pre">start.sh</span></code>脚本:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#!/bin/bash
chown fp:fp /logs
exec gosu fp java -jar fp-frontend-$APP_VERSION.jar
</pre></div>
</div>
<p>给脚本赋权限(<code class="docutils literal notranslate"><span class="pre">chmod</span> <span class="pre">+x</span> <span class="pre">start.sh</span></code>)</p>
<p>修改Dockerfile:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 将启动脚本拷贝至容器，/usr/local/bin默认在PATH路径下</span>
<span class="n">COPY</span> <span class="n">start</span><span class="o">.</span><span class="n">sh</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span>

<span class="c1">## 需改ENTRYPOINT</span>
<span class="n">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&quot;start.sh&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>参考源码<a class="reference external" href="http://gitlab.yitu-inc.com/devops/observability/fp-frontend/tree/docker-0.2">docker-0.2</a>分支。</p>
<p>构建镜像，按照挂载卷的方式启动容器，验证。</p>
</div>
</div>
<div class="section" id="id10">
<h3>4.3.2. 镜像管理<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>在本地通过<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">build</span></code>命令构建镜像，只存在本地镜像仓库，不方便共享部署。该章节介绍如何使用镜像仓库来管理和共享镜像。</p>
<p>这里使用的是公司的<a class="reference external" href="https://harbor.yitu-inc.com/harbor/projects">harbor</a>。</p>
<ul>
<li><p class="first">首先，使用域账号登录harbor: https://harbor.yitu-inc.com/harbor/projects，创建个人项目，例如 <code class="docutils literal notranslate"><span class="pre">docker-in-action</span></code>。</p>
<blockquote>
<div><p>注意: 此处是验证用途，将项目设置为私有。</p>
</div></blockquote>
<p>如果要共享镜像，需要将镜像推送(<code class="docutils literal notranslate"><span class="pre">push</span></code>)到仓库中。</p>
</li>
<li><p class="first">接着，需要在本地登录镜像仓库:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## 登录镜像仓库，输入域账号用户名和密码</span>
<span class="o">&gt;</span> <span class="n">sudo</span> <span class="n">docker</span> <span class="n">login</span> <span class="n">harbor</span><span class="o">.</span><span class="n">yitu</span><span class="o">-</span><span class="n">inc</span><span class="o">.</span><span class="n">com</span>
<span class="n">Username</span> <span class="p">(</span><span class="n">loulou</span><span class="o">.</span><span class="n">liu</span><span class="p">):</span> 
<span class="n">Password</span><span class="p">:</span> 
<span class="n">Login</span> <span class="n">Succeeded</span>
</pre></div>
</div>
</li>
<li><p class="first">修改镜像名称</p>
<p>镜像要推送到仓库，镜像名称中必须带上仓库的地址信息。格式为 <code class="docutils literal notranslate"><span class="pre">&lt;repo_url&gt;/&lt;project_name&gt;/&lt;image_name&gt;:&lt;image_tag&gt;</span></code>。</p>
<p>这里要使用到<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">tag</span></code>命令，格式为: <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">tag</span> <span class="pre">SOURCE_IMAGE[:TAG]</span> <span class="pre">TARGET_IMAGE[:TAG]</span></code>。</p>
<p>按照格式，修改<code class="docutils literal notranslate"><span class="pre">fp/frontend:0.0.1</span></code>镜像名称:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">tag</span> <span class="n">fp</span><span class="o">/</span><span class="n">frontend</span><span class="p">:</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span> <span class="n">harbor</span><span class="o">.</span><span class="n">yitu</span><span class="o">-</span><span class="n">inc</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">docker</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">action</span><span class="o">/</span><span class="n">fp</span><span class="o">/</span><span class="n">frontend</span><span class="p">:</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p class="first">推送镜像</p>
<p>推送镜像，使用的<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">push</span> <span class="pre">&lt;image_name&gt;:&lt;image_tag&gt;</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">push</span> <span class="n">harbor</span><span class="o">.</span><span class="n">yitu</span><span class="o">-</span><span class="n">inc</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">docker</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">action</span><span class="o">/</span><span class="n">fp</span><span class="o">/</span><span class="n">frontend</span><span class="p">:</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span>
</pre></div>
</div>
<p>输出如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">push</span> <span class="n">refers</span> <span class="n">to</span> <span class="n">a</span> <span class="n">repository</span> <span class="p">[</span><span class="n">harbor</span><span class="o">.</span><span class="n">yitu</span><span class="o">-</span><span class="n">inc</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">docker</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">action</span><span class="o">/</span><span class="n">fp</span><span class="o">/</span><span class="n">frontend</span><span class="p">]</span>
<span class="mi">174</span><span class="n">c6af1069e</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="n">a66ac566a07f</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="mi">752</span><span class="n">b23d46029</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="mi">94</span><span class="n">cf736a7b95</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="mi">2</span><span class="n">d63501da7e5</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="n">e6ae888dd260</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="mi">80917357</span><span class="n">f055</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="n">bfc5dbc4d7a7</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="n">b53b57a50746</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="n">d2518892581f</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="n">c581f4ede92d</span><span class="p">:</span> <span class="n">Pushed</span> 
<span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span><span class="p">:</span> <span class="n">digest</span><span class="p">:</span> <span class="n">sha256</span><span class="p">:</span><span class="n">a891febf089db7db1e965ef036aee56bf1053f7a58458397fb575b5088dd7a5f</span> <span class="n">size</span><span class="p">:</span> <span class="mi">2624</span>
</pre></div>
</div>
<p>上传完成后，刷新harbor页面，即可在 镜像仓库 页面看到刚上传的镜像了。</p>
<p>那在其他环境上，就可以通过<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">pull</span> <span class="pre">harbor.yitu-inc.com/docker-in-action/fp/frontend:0.0.1</span></code>的方式拉取镜像了。</p>
<blockquote>
<div><p>说明: 此处设置项目的访问界别为 私有 ，拉取镜像需要login。如果设置为 公开，这无需login。</p>
</div></blockquote>
<blockquote>
<div><p>注意: 这里拉取镜像时，镜像名称不再是 fp/frontend，而是带有镜像仓库地址的。实际上，对于不带仓库地址的镜像，在拉取时，是从设置的默认镜像仓库中拉取的。</p>
</div></blockquote>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">fp/backend</span></code>工程类似，可以参考着制作镜像。具体的可参考源码中的Dockerfile。</p>
</div>
</div>
<div class="section" id="id11">
<h2>4.4. 部署<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>模拟服务的请求流向大概如下:</p>
<p><img alt="../_images/request-flow.png" src="../_images/request-flow.png" /></p>
<p>图4.1 示例应用请求流向</p>
<p>这里需要部署两个应用(<code class="docutils literal notranslate"><span class="pre">fp-frontend</span></code>和<code class="docutils literal notranslate"><span class="pre">fp-backend</span></code>)，以及外部存储服务(<code class="docutils literal notranslate"><span class="pre">mysql</span></code>)。</p>
<div class="section" id="mysql">
<h3>4.4.1. mysql<a class="headerlink" href="#mysql" title="Permalink to this headline">¶</a></h3>
<p>首先，部署mysql服务。这里直接使用docker官网镜像--<code class="docutils literal notranslate"><span class="pre">mysql:5.7</span></code>。</p>
<ul class="simple">
<li>启动服务</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">--</span><span class="n">name</span> <span class="n">mysql</span> <span class="o">-</span><span class="n">e</span> <span class="n">MYSQL_ROOT_PASSWORD</span><span class="o">=&lt;</span><span class="n">root_password</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">v</span> <span class="o">&lt;</span><span class="n">mysql_data_volume</span><span class="o">&gt;</span><span class="p">:</span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">mysql</span> <span class="o">--</span><span class="n">restart</span><span class="o">=</span><span class="n">always</span> <span class="o">-</span><span class="n">p</span> <span class="mi">3306</span><span class="p">:</span><span class="mi">3306</span> <span class="n">mysql</span><span class="p">:</span><span class="mf">5.7</span> <span class="o">--</span><span class="n">character</span><span class="o">-</span><span class="nb">set</span><span class="o">-</span><span class="n">server</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="o">--</span><span class="n">collation</span><span class="o">-</span><span class="n">server</span><span class="o">=</span><span class="n">utf8mb4_unicode_ci</span>
</pre></div>
</div>
<blockquote>
<div><p>说明:</p>
<ul class="simple">
<li>&lt;root_password&gt;: root用户的密码，需要修改。示例应用中使用的是root。</li>
<li>&lt;mysql_data_volume&gt;: 本地挂载卷，持久化mysql数据，需要修改。</li>
<li>需要将mysql作为服务，所以需要将3306端口映射出来，示例应用中使用的是3306，如存在端口占用，可以修改。</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>建表</li>
</ul>
<p>示例应用中需要访问数据表，参考如下命令初始化数据:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>## 在docker容器中，执行建库建表操作
sudo docker exec -ti mysql bash

## 登录

&gt; mysql -u root -h 127.0.0.1 -p
输入密码

## 建库，schema为fp
&gt; create database fp;

## 创建用户，用户名和密码均为fp
&gt;  use fp;
&gt; create user fp identified by &#39;fp&#39;;
&gt; grant all privileges on *.* to fp@&#39;%&#39; identified by &#39;fp&#39;;

## 建表，表名为 resource
&gt; create table resource (
	id int(11) not null auto_increment primary key,
    `born-year` smallint(6) not null default 0,
    `face-image-id` bigint not null default 0,
    `face-image-uri` varchar(64) character set utf8 not null default &#39;&#39;,
    `gender` tinyint(2) not null default 0,
    `name` varchar(16) character set utf8 not null default &#39;&#39;,
    `person-id` int(11) not null default 0,
    `picture-uri` varchar(128) character set utf8 not null default &#39;&#39;
) charset=utf8;

## 写入测试数据
&gt; insert into resource (`born-year`, `face-image-id`, `face-image-uri`, `gender`, `name`, `person-id`, `picture-uri`) values (&#39;76&#39;, &#39;3288935160016879295&#39;, &#39;BrScBCcHlmKAfybIQqMu&#39;, &#39;0&#39;, &#39;KGPJhDclQ3&#39;, &#39;120905&#39;, &#39;xGTcUWP5x7rO7ZewlHDs&#39;
);
</pre></div>
</div>
<p>退出容器。</p>
</div>
<div class="section" id="fp-backend">
<h3>4.4.2. fp-backend<a class="headerlink" href="#fp-backend" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>说明: 最终镜像已推送至 harbor，可通过 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">pull</span> <span class="pre">harbor.yitu-inc.com/observability/fp/backend:0.0.1</span></code>拉取。</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">fp-backend</span></code>中需要连接<code class="docutils literal notranslate"><span class="pre">mysql</span></code>数据库，连接信息是在源码<a class="reference external" href="http://gitlab.yitu-inc.com/devops/observability/fp-backend/blob/master/src/main/resources/application-dev.yml">application-dev.yml</a>。如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/fp?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false
    username: fp
    password: fp
</pre></div>
</div>
<p>而在部署中，需要根据实际的<code class="docutils literal notranslate"><span class="pre">mysql</span></code>服务修改配置。</p>
<p>这里有两种方式，一是通过挂载卷的方式，在主机上保存一份<code class="docutils literal notranslate"><span class="pre">application-dev.yml</span></code>，通过挂载的方式映射到容器中；一是通过环境变量的方式。这里使用第二种方式。(第一种可以参考日志目录挂载的方式自行验证，需要注意的是，<code class="docutils literal notranslate"><span class="pre">-v</span></code>参数中主机上的配置文件路径需要是绝对路径)。</p>
<p>通过环境变量传入参数，需要两部分，一是配置文件中修改为环境变量的方式(<code class="docutils literal notranslate"><span class="pre">spring</span> <span class="pre">boot</span></code>的方式，其他语言框架类同)；一是在启动容器的时候，传入环境变量。</p>
<ul class="simple">
<li>修改配置文件，如下：</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://${MYSQL_HOST}:${MYSQL_PORT}/${MYSQL_DATABASE}?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false
    username: ${MYSQL_USERNAME}
    password: ${MYSQL_PASSWORD}
</pre></div>
</div>
<blockquote>
<div>说明: 定义了 <code class="docutils literal notranslate"><span class="pre">MYSQL_HOST</span></code>，<code class="docutils literal notranslate"><span class="pre">MYSQL_PORT</span></code>，<code class="docutils literal notranslate"><span class="pre">MYSQL_DATABASE</span></code>，<code class="docutils literal notranslate"><span class="pre">MYSQL_USERNAME</span></code>，<code class="docutils literal notranslate"><span class="pre">MYSQL_PASSWORD</span></code> 五个环境变量。</div></blockquote>
<p>参考源码<a class="reference external" href="http://gitlab.yitu-inc.com/devops/observability/fp-backend/tree/docker-0.1">docker-0.1</a>分支。</p>
<ul class="simple">
<li>重新构建镜像</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">fp</span><span class="o">/</span><span class="n">backend</span><span class="p">:</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span> <span class="o">.</span>
</pre></div>
</div>
<ul class="simple">
<li>运行容器</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">--</span><span class="n">name</span> <span class="n">fp</span><span class="o">-</span><span class="n">backend</span> <span class="o">-</span><span class="n">e</span> <span class="n">MYSQL_HOST</span><span class="o">=</span><span class="mf">10.10</span><span class="o">.</span><span class="mf">23.115</span> <span class="o">-</span><span class="n">e</span> <span class="n">MYSQL_PORT</span><span class="o">=</span><span class="mi">3307</span> <span class="o">-</span><span class="n">e</span> <span class="n">MYSQL_DATABASE</span><span class="o">=</span><span class="n">fp</span> <span class="o">-</span><span class="n">e</span> <span class="n">MYSQL_USERNAME</span><span class="o">=</span><span class="n">fp</span> <span class="o">-</span><span class="n">e</span> <span class="n">MYSQL_PASSWORD</span><span class="o">=</span><span class="n">fp</span> <span class="o">-</span><span class="n">p</span> <span class="mi">8082</span><span class="p">:</span><span class="mi">8082</span> <span class="n">fp</span><span class="o">/</span><span class="n">backend</span><span class="p">:</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span>
</pre></div>
</div>
<blockquote>
<div><p>说明:</p>
<ul class="simple">
<li>按照之前定义的环境变量，通过<code class="docutils literal notranslate"><span class="pre">-e</span></code>参数依次传入</li>
<li><code class="docutils literal notranslate"><span class="pre">fp-backend</span></code>对外提供HTTP服务，暴露端口为 <code class="docutils literal notranslate"><span class="pre">8082</span></code>，需要通过<code class="docutils literal notranslate"><span class="pre">-p</span></code>参数映射到主机。</li>
</ul>
</div></blockquote>
<blockquote>
<div>注意: 在指定<code class="docutils literal notranslate"><span class="pre">mysql</span></code>服务的IP时，需要指定主机上的公网IP，不能使用<code class="docutils literal notranslate"><span class="pre">localhost</span></code>或者<code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code>。因为是在容器中访问的<code class="docutils literal notranslate"><span class="pre">mysql</span></code>，指定<code class="docutils literal notranslate"><span class="pre">localhost</span></code>访问的是容器内部网络。(可以通过--network=host启动<code class="docutils literal notranslate"><span class="pre">mysql</span></code>)。</div></blockquote>
<ul class="simple">
<li>验证</li>
</ul>
<p>访问 <code class="docutils literal notranslate"><span class="pre">http://localhost:8082/fp/backend/track/fetch</span></code>，结果如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;bornYear&quot;</span><span class="p">:</span> <span class="mi">76</span><span class="p">,</span>
        <span class="s2">&quot;faceImageId&quot;</span><span class="p">:</span> <span class="mi">3288935160016879295</span><span class="p">,</span>
        <span class="s2">&quot;faceImageUri&quot;</span><span class="p">:</span> <span class="s2">&quot;BrScBCcHlmKAfybIQqMu&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gender&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;KGPJhDclQ3&quot;</span><span class="p">,</span>
        <span class="s2">&quot;personId&quot;</span><span class="p">:</span> <span class="mi">120905</span><span class="p">,</span>
        <span class="s2">&quot;pictureUri&quot;</span><span class="p">:</span> <span class="s2">&quot;xGTcUWP5x7rO7ZewlHDs&quot;</span>
    <span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="fp-frontend">
<h3>4.4.3. fp-frontend<a class="headerlink" href="#fp-frontend" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>说明: 最终镜像已推送至 harbor，可以通过<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">pull</span> <span class="pre">harbor.yitu-inc.com/observability/fp/frontend:0.0.1</span></code>拉取。</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">fp-frontend</span></code>需要访问<code class="docutils literal notranslate"><span class="pre">fp-backend</span></code>的接口，同样，需要定制化配置。参考源码中<a class="reference external" href="http://gitlab.yitu-inc.com/devops/observability/fp-frontend/blob/docker-0.3/src/main/resources/application-dev.yml">docker-0.3</a>分支。</p>
<p>重新构建镜像。</p>
<ul class="simple">
<li>启动容器</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sudo docker run -d --name fp-frontend -e FP_BACKEND_HOST=10.10.23.115 -v $PWD/logs:/logs -p 8081:8081 fp/frontend:0.0.3
</pre></div>
</div>
<blockquote>
<div><p>说明:</p>
<ul class="simple">
<li>FP_BACKEND_HOST: 与mysql类似，这里应该指定公网IP</li>
<li>FP_BACKEND_PORT: 配置文件中给出了默认值8082，与实际运行情况一致，这里无需指定了。</li>
<li><code class="docutils literal notranslate"><span class="pre">fp-frontend</span></code>对外暴露<code class="docutils literal notranslate"><span class="pre">8081</span></code>端口。</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>验证</li>
</ul>
<p>访问<code class="docutils literal notranslate"><span class="pre">http://localhost:8081/fp/frontend/log/fetch/1</span></code>，结果如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SYeSxTc5UAFlp7lX7j3D</span>
</pre></div>
</div>
<p>这时，可以通过<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">docker</span> <span class="pre">logs</span></code>查询<code class="docutils literal notranslate"><span class="pre">fp-frontend</span></code>和<code class="docutils literal notranslate"><span class="pre">fp-backend</span></code>的日志，查看调用过程。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="appendix.html" class="btn btn-neutral float-right" title="5. 附录" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="basic_cmd.html" class="btn btn-neutral" title="3. 基本操作" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, loulou.liu

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>