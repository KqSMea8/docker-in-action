

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="cn" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="cn" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5. 附录 &mdash; docker-in-action 0.1.alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="4. 实践" href="practice.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> docker-in-action
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">1. Getting Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_concept.html">2. 基本概念</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_cmd.html">3. 基本操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="practice.html">4. 实践</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. 附录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">5.1. 容器化规范</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">5.2. 最佳实践</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">5.2.1. 一般性的指南和建议</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">5.2.1.1. 容器应该是短暂的</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dockerignore">5.2.1.2. 使用 .dockerignore 文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">5.2.1.3. 使用多阶段构建</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">5.2.1.4. 避免安装不必要的包</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">5.2.1.5. 一个容器只运行一个进程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">5.2.1.6. 镜像层数尽可能少</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">5.2.1.7. 将多行参数排序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">5.2.1.8. 构建缓存</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dockerfile">5.2.2. Dockerfile 指令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#from">5.2.2.1. FROM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#label">5.2.2.2. LABEL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#run">5.2.2.3. RUN</a></li>
<li class="toctree-l4"><a class="reference internal" href="#apt-get">5.2.2.4. apt-get</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cmd">5.2.2.5. CMD</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expose">5.2.2.6. EXPOSE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#env">5.2.2.7. ENV</a></li>
<li class="toctree-l4"><a class="reference internal" href="#add-copy">5.2.2.8. ADD 和 COPY</a></li>
<li class="toctree-l4"><a class="reference internal" href="#entrypoint">5.2.2.9. ENTRYPOINT</a></li>
<li class="toctree-l4"><a class="reference internal" href="#volume">5.2.2.10. VOLUME</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user">5.2.2.11. USER</a></li>
<li class="toctree-l4"><a class="reference internal" href="#workdir">5.2.2.12. WORKDIR</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#q-a">5.3. Q&amp;A</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">docker-in-action</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>5. 附录</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/docker/appendix.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>5. 附录<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>5.1. 容器化规范<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://confluence.yitu-inc.com/pages/viewpage.action?pageId=307495610">容器化规范</a>。</p>
</div>
<div class="section" id="id3">
<h2>5.2. 最佳实践<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id4">
<h3>5.2.1. 一般性的指南和建议<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id5">
<h4>5.2.1.1. 容器应该是短暂的<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p>
</div>
<div class="section" id="dockerignore">
<h4>5.2.1.2. 使用 .dockerignore 文件<a class="headerlink" href="#dockerignore" title="Permalink to this headline">¶</a></h4>
<p>使用 Dockerfile 构建镜像时最好是将 Dockerfile 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 .dockerignore 文件来指定要忽略的文件和目录。.dockerignore 文件的排除模式语法和 Git 的 .gitignore 文件相似。</p>
</div>
<div class="section" id="id6">
<h4>5.2.1.3. 使用多阶段构建<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>在 Docker 17.05 以上版本中，你可以使用 多阶段构建 来减少所构建镜像的大小。</p>
</div>
<div class="section" id="id7">
<h4>5.2.1.4. 避免安装不必要的包<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p>
</div>
<div class="section" id="id8">
<h4>5.2.1.5. 一个容器只运行一个进程<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。</p>
<p>如果容器互相依赖，你可以使用 Docker 自定义网络 来把这些容器连接起来。</p>
</div>
<div class="section" id="id9">
<h4>5.2.1.6. 镜像层数尽可能少<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>你需要在 Dockerfile 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p>
</div>
<div class="section" id="id10">
<h4>5.2.1.7. 将多行参数排序<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 PRs 阅读和审查。建议在反斜杠符号 \ 之前添加一个空格，以增加可读性。</p>
<p>下面是来自 buildpack-deps 镜像的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">&amp;&amp;</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> \
  <span class="n">bzr</span> \
  <span class="n">cvs</span> \
  <span class="n">git</span> \
  <span class="n">mercurial</span> \
  <span class="n">subversion</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h4>5.2.1.8. 构建缓存<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>在镜像的构建过程中，Docker 会遍历 Dockerfile 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用 --no-cache=true 选项。</p>
<p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：</p>
<p>从一个基础镜像开始（FROM 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。
在大多数情况下，只需要简单地对比 Dockerfile 中的指令和子镜像。然而，有些指令需要更多的检查和解释。
对于 ADD 和 COPY 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。
除了 ADD 和 COPY 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 RUN apt-get -y update 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。
一旦缓存失效，所有后续的 Dockerfile 指令都将产生新的镜像，缓存不会被使用。</p>
</div>
</div>
<div class="section" id="dockerfile">
<h3>5.2.2. Dockerfile 指令<a class="headerlink" href="#dockerfile" title="Permalink to this headline">¶</a></h3>
<p>下面针对 Dockerfile 中各种指令的最佳编写方式给出建议。</p>
<div class="section" id="from">
<h4>5.2.2.1. FROM<a class="headerlink" href="#from" title="Permalink to this headline">¶</a></h4>
<p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 Alpine 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p>
</div>
<div class="section" id="label">
<h4>5.2.2.2. LABEL<a class="headerlink" href="#label" title="Permalink to this headline">¶</a></h4>
<p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 LABEL 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。# 开头的行是注释内容。</p>
<p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set one or more individual labels</span>
<span class="n">LABEL</span> <span class="n">com</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.0.1-beta&quot;</span>

<span class="n">LABEL</span> <span class="n">vendor</span><span class="o">=</span><span class="s2">&quot;ACME Incorporated&quot;</span>

<span class="n">LABEL</span> <span class="n">com</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">release</span><span class="o">-</span><span class="n">date</span><span class="o">=</span><span class="s2">&quot;2015-02-12&quot;</span>

<span class="n">LABEL</span> <span class="n">com</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="ow">is</span><span class="o">-</span><span class="n">production</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
</pre></div>
</div>
<p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 LABEL 指令中。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set multiple labels at once, using line-continuation characters to break long lines</span>
<span class="n">LABEL</span> <span class="n">vendor</span><span class="o">=</span><span class="n">ACME</span>\ <span class="n">Incorporated</span> \
      <span class="n">com</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="ow">is</span><span class="o">-</span><span class="n">beta</span><span class="o">=</span> \
      <span class="n">com</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="ow">is</span><span class="o">-</span><span class="n">production</span><span class="o">=</span><span class="s2">&quot;&quot;</span> \
      <span class="n">com</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.0.1-beta&quot;</span> \
      <span class="n">com</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">release</span><span class="o">-</span><span class="n">date</span><span class="o">=</span><span class="s2">&quot;2015-02-12&quot;</span>
</pre></div>
</div>
<p>关于标签可以接受的键值对，参考 <a class="reference external" href="https://docs.docker.com/config/labels-custom-metadata/">Understanding object labels</a>。关于查询标签信息，参考 <a class="reference external" href="https://docs.docker.com/config/labels-custom-metadata/">Managing labels on objects</a>。</p>
</div>
<div class="section" id="run">
<h4>5.2.2.3. RUN<a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h4>
<p>为了保持 <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code class="docutils literal notranslate"><span class="pre">RUN</span></code> 指令用反斜杠<code class="docutils literal notranslate"><span class="pre">\</span></code> 分割成多行。</p>
</div>
<div class="section" id="apt-get">
<h4>5.2.2.4. apt-get<a class="headerlink" href="#apt-get" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">RUN</span></code> 指令最常见的用法是安装包用的 <code class="docutils literal notranslate"><span class="pre">apt-get</span></code>。因为 <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">apt-get</span></code> 指令会安装包，所以有几个问题需要注意。</p>
<p>不要使用 <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">apt-get</span> <span class="pre">upgrade</span></code> 或 <code class="docutils literal notranslate"><span class="pre">dist-upgrade</span></code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code class="docutils literal notranslate"><span class="pre">foo</span></code>，需要升级，使用 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">-y</span> <span class="pre">foo</span></code> 就行，该指令会自动升级 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 包。</p>
<p>永远将 <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">apt-get</span> <span class="pre">update</span></code> 和 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">install</span></code> 组合成一条 <code class="docutils literal notranslate"><span class="pre">RUN</span></code> 声明，例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">&amp;&amp;</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> \
        <span class="n">package</span><span class="o">-</span><span class="n">bar</span> \
        <span class="n">package</span><span class="o">-</span><span class="n">baz</span> \
        <span class="n">package</span><span class="o">-</span><span class="n">foo</span>
</pre></div>
</div>
<p>将 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">update</span></code> 放在一条单独的 RUN 声明中会导致缓存问题以及后续的 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">install</span></code> 失败。比如，假设你有一个 Dockerfile 文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">18.04</span>

<span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span>

<span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">curl</span>
</pre></div>
</div>
<p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">install</span></code> 添加了一个包：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">18.04</span>

<span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span>

<span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> <span class="n">curl</span> <span class="n">nginx</span>
</pre></div>
</div>
<p>Docker 发现修改后的 <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">apt-get</span> <span class="pre">update</span></code> 指令和之前的完全一样。所以，<code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">update</span></code> 不会执行，而是使用之前的缓存镜像。因为 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">update</span></code> 没有运行，后面的 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">install</span></code> 可能安装的是过时的 <code class="docutils literal notranslate"><span class="pre">curl</span></code> 和 <code class="docutils literal notranslate"><span class="pre">nginx</span></code> 版本。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">apt-get</span> <span class="pre">update</span> <span class="pre">&amp;&amp;</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">-y</span></code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code class="docutils literal notranslate"><span class="pre">cache</span> <span class="pre">busting</span></code>。你也可以显示指定一个包的版本号来达到 <code class="docutils literal notranslate"><span class="pre">cache-busting</span></code>，这就是所谓的固定版本，例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">&amp;&amp;</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> \
    <span class="n">package</span><span class="o">-</span><span class="n">bar</span> \
    <span class="n">package</span><span class="o">-</span><span class="n">baz</span> \
    <span class="n">package</span><span class="o">-</span><span class="n">foo</span><span class="o">=</span><span class="mf">1.3</span><span class="o">.*</span>
</pre></div>
</div>
<p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p>
<p>下面是一个 RUN 指令的示例模板，展示了所有关于 apt-get 的建议。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span> <span class="o">&amp;&amp;</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="o">-</span><span class="n">y</span> \
    <span class="n">aufs</span><span class="o">-</span><span class="n">tools</span> \
    <span class="n">automake</span> \
    <span class="n">build</span><span class="o">-</span><span class="n">essential</span> \
    <span class="n">curl</span> \
    <span class="n">dpkg</span><span class="o">-</span><span class="n">sig</span> \
    <span class="n">libcap</span><span class="o">-</span><span class="n">dev</span> \
    <span class="n">libsqlite3</span><span class="o">-</span><span class="n">dev</span> \
    <span class="n">mercurial</span> \
    <span class="n">reprepro</span> \
    <span class="n">ruby1</span><span class="o">.</span><span class="mf">9.1</span> \
    <span class="n">ruby1</span><span class="o">.</span><span class="mf">9.1</span><span class="o">-</span><span class="n">dev</span> \
    <span class="n">s3cmd</span><span class="o">=</span><span class="mf">1.1</span><span class="o">.*</span> \
 <span class="o">&amp;&amp;</span> <span class="n">rm</span> <span class="o">-</span><span class="n">rf</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">apt</span><span class="o">/</span><span class="n">lists</span><span class="o">/*</span>
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">s3cmd</span></code> 指令指定了一个版本号 <code class="docutils literal notranslate"><span class="pre">1.1.*</span></code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">udpate</span></code> 缓存失效并确保安装的是新版本。</p>
<p>另外，清理掉 <code class="docutils literal notranslate"><span class="pre">apt</span></code> 缓存 <code class="docutils literal notranslate"><span class="pre">var/lib/apt/lists</span></code>可以减小镜像大小。因为 RUN 指令的开头为 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">udpate</span></code>，包缓存总是会在 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">install</span></code> 之前刷新。</p>
<p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">clean</span></code>，所以不需要显式的调用 <code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">clean</span></code>。</p>
</div>
<div class="section" id="cmd">
<h4>5.2.2.5. CMD<a class="headerlink" href="#cmd" title="Permalink to this headline">¶</a></h4>
<p>CMD 指令用于执行目标镜像中包含的软件，可以包含参数。CMD 大多数情况下都应该以 CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...] 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 Apache)，你可能会执行类似于 CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;] 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p>
<p>多数情况下，CMD 都需要一个交互式的 shell (bash, Python, perl 等)，例如 CMD [&quot;perl&quot;, &quot;-de0&quot;]，或者 CMD [&quot;PHP&quot;, &quot;-a&quot;]。使用这种形式意味着，当你执行类似 docker run -it python 时，你会进入一个准备好的 shell 中。CMD 应该在极少的情况下才能以 CMD [&quot;param&quot;, &quot;param&quot;] 的形式与 ENTRYPOINT 协同使用，除非你和你的镜像使用者都对 ENTRYPOINT 的工作方式十分熟悉。</p>
</div>
<div class="section" id="expose">
<h4>5.2.2.6. EXPOSE<a class="headerlink" href="#expose" title="Permalink to this headline">¶</a></h4>
<p>EXPOSE 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 Apache web 服务的镜像应该使用 EXPOSE 80，而提供 MongoDB 服务的镜像使用 EXPOSE 27017。</p>
<p>对于外部访问，用户可以在执行 docker run 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p>
</div>
<div class="section" id="env">
<h4>5.2.2.7. ENV<a class="headerlink" href="#env" title="Permalink to this headline">¶</a></h4>
<p>为了方便新程序运行，你可以使用 ENV 来为容器中安装的程序更新 PATH 环境变量。例如使用 ENV PATH /usr/local/nginx/bin:$PATH 来确保 CMD [&quot;nginx&quot;] 能正确运行。</p>
<p>ENV 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 PGDATA。</p>
<p>最后，ENV 也能用于设置常见的版本号，比如下面的示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ENV PG_MAJOR 9.3

ENV PG_VERSION 9.3.4

RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …

ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH
</pre></div>
</div>
<p>类似于程序中的常量，这种方法可以让你只需改变 ENV 指令来自动的改变容器中的软件版本。</p>
</div>
<div class="section" id="add-copy">
<h4>5.2.2.8. ADD 和 COPY<a class="headerlink" href="#add-copy" title="Permalink to this headline">¶</a></h4>
<p>虽然 ADD 和 COPY 功能类似，但一般优先使用 COPY。因为它比 ADD 更透明。COPY 只支持简单将本地文件拷贝到容器中，而 ADD 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，ADD 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 ADD rootfs.tar.xz。</p>
<p>如果你的 Dockerfile 有多个步骤需要使用上下文中不同的文件。单独 COPY 每个文件，而不是一次性的 COPY 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">COPY</span> <span class="n">requirements</span><span class="o">.</span><span class="n">txt</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span>

<span class="n">RUN</span> <span class="n">pip</span> <span class="n">install</span> <span class="o">--</span><span class="n">requirement</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">requirements</span><span class="o">.</span><span class="n">txt</span>

<span class="n">COPY</span> <span class="o">.</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span>
</pre></div>
</div>
<p>如果将 <code class="docutils literal notranslate"><span class="pre">COPY</span> <span class="pre">.</span> <span class="pre">/tmp/</span></code> 放置在 RUN 指令之前，只要 <code class="docutils literal notranslate"><span class="pre">.</span></code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p>
<p>为了让镜像尽量小，最好不要使用 ADD 指令从远程 URL 获取包，而是使用 curl 和 wget。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ADD</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">big</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">xz</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">things</span><span class="o">/</span>

<span class="n">RUN</span> <span class="n">tar</span> <span class="o">-</span><span class="n">xJf</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">things</span><span class="o">/</span><span class="n">big</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">xz</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">things</span>

<span class="n">RUN</span> <span class="n">make</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">things</span> <span class="nb">all</span>
</pre></div>
</div>
<p>而是应该使用下面这种方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="n">mkdir</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">things</span> \
    <span class="o">&amp;&amp;</span> <span class="n">curl</span> <span class="o">-</span><span class="n">SL</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">big</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">xz</span> \
    <span class="o">|</span> <span class="n">tar</span> <span class="o">-</span><span class="n">xJC</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">things</span> \
    <span class="o">&amp;&amp;</span> <span class="n">make</span> <span class="o">-</span><span class="n">C</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">things</span> <span class="nb">all</span>
</pre></div>
</div>
<p>上面使用的管道操作，所以没有中间文件需要删除。</p>
<p>对于其他不需要 ADD 的自动提取功能的文件或目录，你应该使用 COPY。</p>
</div>
<div class="section" id="entrypoint">
<h4>5.2.2.9. ENTRYPOINT<a class="headerlink" href="#entrypoint" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用<code class="docutils literal notranslate"><span class="pre">CMD</span></code> 提供默认选项）。</p>
<p>例如，下面的示例镜像提供了命令行工具 s3cmd:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&quot;s3cmd&quot;</span><span class="p">]</span>

<span class="n">CMD</span> <span class="p">[</span><span class="s2">&quot;--help&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>现在直接运行该镜像创建的容器会显示命令帮助：</p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">docker</span> <span class="pre">run</span> <span class="pre">s3cmd</span></code>
或者提供正确的参数来执行某个命令：</p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">docker</span> <span class="pre">run</span> <span class="pre">s3cmd</span> <span class="pre">ls</span> <span class="pre">s3://mybucket</span></code>
这样镜像名可以当成命令行的参考。</p>
<p><code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p>
<p>例如，Postgres 官方镜像使用下面的脚本作为 <code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#!/bin/bash
set -e

if [ &quot;$1&quot; = &#39;postgres&#39; ]; then
    chown -R postgres &quot;$PGDATA&quot;

    if [ -z &quot;$(ls -A &quot;$PGDATA&quot;)&quot; ]; then
        gosu postgres initdb
    fi

    exec gosu postgres &quot;$@&quot;
fi

exec &quot;$@&quot;
</pre></div>
</div>
<p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p>
<p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 执行：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">COPY</span> <span class="o">./</span><span class="n">docker</span><span class="o">-</span><span class="n">entrypoint</span><span class="o">.</span><span class="n">sh</span> <span class="o">/</span>

<span class="n">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&quot;/docker-entrypoint.sh&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>该脚本可以让用户用几种不同的方式和 Postgres 交互。</p>
<p>你可以很简单地启动 Postgres：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run postgres
</pre></div>
</div>
<p>也可以执行 Postgres 并传递参数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run postgres postgres --help
</pre></div>
</div>
<p>最后，你还可以启动另外一个完全不同的工具，比如 Bash：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker run --rm -it postgres bash
</pre></div>
</div>
</div>
<div class="section" id="volume">
<h4>5.2.2.10. VOLUME<a class="headerlink" href="#volume" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">VOLUME</span></code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code class="docutils literal notranslate"><span class="pre">VOLUME</span></code> 来管理镜像中的可变部分和用户可以改变的部分。</p>
</div>
<div class="section" id="user">
<h4>5.2.2.11. USER<a class="headerlink" href="#user" title="Permalink to this headline">¶</a></h4>
<p>如果某个服务不需要特权执行，建议使用 USER 指令切换到非 root 用户。先在 Dockerfile 中使用类似 <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">groupadd</span> <span class="pre">-r</span> <span class="pre">postgres</span> <span class="pre">&amp;&amp;</span> <span class="pre">useradd</span> <span class="pre">-r</span> <span class="pre">-g</span> <span class="pre">postgres</span> <span class="pre">postgres</span></code> 的指令创建用户和用户组。</p>
<p>注意：在镜像中，用户和用户组每次被分配的 <code class="docutils literal notranslate"><span class="pre">UID/GID</span></code> 都是不确定的，下次重新构建镜像时被分配到的 <code class="docutils literal notranslate"><span class="pre">UID/GID</span></code> 可能会不一样。如果要依赖确定的 <code class="docutils literal notranslate"><span class="pre">UID/GID</span></code>，你应该显示的指定一个 <code class="docutils literal notranslate"><span class="pre">UID/GID</span></code>。</p>
<p>你应该避免使用 <code class="docutils literal notranslate"><span class="pre">sudo</span></code>，因为它不可预期的 <code class="docutils literal notranslate"><span class="pre">TTY</span></code> 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 sudo 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <code class="docutils literal notranslate"><span class="pre">gosu</span></code>。</p>
<p>最后，为了减少层数和复杂度，避免频繁地使用 USER 来回切换用户。</p>
</div>
<div class="section" id="workdir">
<h4>5.2.2.12. WORKDIR<a class="headerlink" href="#workdir" title="Permalink to this headline">¶</a></h4>
<p>为了清晰性和可靠性，你应该总是在 <code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code> 中使用绝对路径。另外，你应该使用 <code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code> 来替代类似于 <code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">cd</span> <span class="pre">...</span> <span class="pre">&amp;&amp;</span> <span class="pre">do-something</span></code> 的指令，后者难以阅读、排错和维护。</p>
</div>
</div>
</div>
<div class="section" id="q-a">
<h2>5.3. Q&amp;A<a class="headerlink" href="#q-a" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="practice.html" class="btn btn-neutral" title="4. 实践" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, loulou.liu

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>