%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}

\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\def\pageautorefname{page}

\setcounter{tocdepth}{1}


	\usepackage{xeCJK}
	\usepackage{indentfirst}
	\setlength{\parindent}{2em}
	\setCJKmainfont{SimSun}
	\setCJKmonofont[Scale=0.9]{SimSun}
	\setCJKfamilyfont{song}{SimSun}
	\setCJKfamilyfont{sf}{SimSun}
	\XeTeXlinebreakskip = 0pt plus 1pt
	\setcounter{tocdepth}{2}
    \setcounter{secnumdepth}{0}
    

\title{docker-in-action Documentation}
\date{Feb 22, 2019}
\release{0.1.alpha}
\author{loulou.liu}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Getting Start}
\label{\detokenize{docker/intro:getting-start}}\label{\detokenize{docker/intro::doc}}

\section{Introduction}
\label{\detokenize{docker/intro:introduction}}

\subsection{什么是Docker}
\label{\detokenize{docker/intro:docker}}
Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。

Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。

下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
\sphinxincludegraphics{{virtualization}.png}



\sphinxincludegraphics{{docker}.png}




\subsection{为什么用Docker}
\label{\detokenize{docker/intro:id1}}
作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。


\subsubsection{更高效的利用系统资源}
\label{\detokenize{docker/intro:id2}}
由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。


\subsubsection{更快速的启动时间}
\label{\detokenize{docker/intro:id3}}
传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。


\subsubsection{一致的运行环境}
\label{\detokenize{docker/intro:id4}}
开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。


\subsubsection{持续交付和部署}
\label{\detokenize{docker/intro:id5}}
对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。
使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。
而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。


\subsubsection{更轻松的迁移}
\label{\detokenize{docker/intro:id6}}
由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。


\subsubsection{更轻松的维护和扩展}
\label{\detokenize{docker/intro:id7}}
Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。


\section{Install and Setup}
\label{\detokenize{docker/intro:install-and-setup}}

\subsection{操作系统}
\label{\detokenize{docker/intro:id8}}\begin{itemize}
\item {} 
ubuntu 14.04(LTS)

\item {} 
ubuntu 16.04(LTS)

\end{itemize}
\begin{quote}

说明: 文档中所使用的测试环境是 \sphinxcode{\sphinxupquote{ubuntu 14.04}}。
\end{quote}


\subsection{安装}
\label{\detokenize{docker/intro:id9}}
\sphinxcode{\sphinxupquote{docker}}目前最新版本是\sphinxcode{\sphinxupquote{v18.09}}(注: 2019.2.11)。最新版本的docker 不支持 \sphinxcode{\sphinxupquote{ubuntu 14.04}}。
安装步骤参考\sphinxhref{https://docs.docker.com/install/linux/docker-ce/ubuntu/}{官网文档}。
\begin{quote}

说明: 文档中所使用的docker版本是 \sphinxcode{\sphinxupquote{v18.06.1}}。
\end{quote}

安装完成后，执行\sphinxcode{\sphinxupquote{sudo docker info}}，即可docker版本信息，如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Containers}\PYG{p}{:} \PYG{l+m+mi}{0}
 \PYG{n}{Running}\PYG{p}{:} \PYG{l+m+mi}{0}
 \PYG{n}{Paused}\PYG{p}{:} \PYG{l+m+mi}{0}
 \PYG{n}{Stopped}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{n}{Images}\PYG{p}{:} \PYG{l+m+mi}{34}
\PYG{n}{Server} \PYG{n}{Version}\PYG{p}{:} \PYG{l+m+mf}{18.06}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{ce}
\PYG{n}{Storage} \PYG{n}{Driver}\PYG{p}{:} \PYG{n}{overlay2}
 \PYG{n}{Backing} \PYG{n}{Filesystem}\PYG{p}{:} \PYG{n}{extfs}
 \PYG{n}{Supports} \PYG{n}{d\PYGZus{}type}\PYG{p}{:} \PYG{n}{true}
 \PYG{n}{Native} \PYG{n}{Overlay} \PYG{n}{Diff}\PYG{p}{:} \PYG{n}{false}
\PYG{n}{Logging} \PYG{n}{Driver}\PYG{p}{:} \PYG{n}{json}\PYG{o}{\PYGZhy{}}\PYG{n}{file}
\PYG{n}{Cgroup} \PYG{n}{Driver}\PYG{p}{:} \PYG{n}{cgroupfs}
\PYG{n}{Plugins}\PYG{p}{:}
 \PYG{n}{Volume}\PYG{p}{:} \PYG{n}{local}
 \PYG{n}{Network}\PYG{p}{:} \PYG{n}{bridge} \PYG{n}{host} \PYG{n}{macvlan} \PYG{n}{null} \PYG{n}{overlay}
 \PYG{n}{Log}\PYG{p}{:} \PYG{n}{awslogs} \PYG{n}{fluentd} \PYG{n}{gcplogs} \PYG{n}{gelf} \PYG{n}{journald} \PYG{n}{json}\PYG{o}{\PYGZhy{}}\PYG{n}{file} \PYG{n}{logentries} \PYG{n}{splunk} \PYG{n}{syslog}
\PYG{n}{Swarm}\PYG{p}{:} \PYG{n}{inactive}
\PYG{n}{Runtimes}\PYG{p}{:} \PYG{n}{runc}
\PYG{n}{Default} \PYG{n}{Runtime}\PYG{p}{:} \PYG{n}{runc}
\PYG{n}{Init} \PYG{n}{Binary}\PYG{p}{:} \PYG{n}{docker}\PYG{o}{\PYGZhy{}}\PYG{n}{init}
\PYG{n}{containerd} \PYG{n}{version}\PYG{p}{:} \PYG{l+m+mi}{468}\PYG{n}{a545b9edcd5932818eb9de8e72413e616e86e}
\PYG{n}{runc} \PYG{n}{version}\PYG{p}{:} \PYG{l+m+mi}{69663}\PYG{n}{f0bd4b60df09991c08812a60108003fa340}
\PYG{n}{init} \PYG{n}{version}\PYG{p}{:} \PYG{n}{fec3683}
\PYG{n}{Security} \PYG{n}{Options}\PYG{p}{:}
 \PYG{n}{apparmor}
\PYG{n}{Kernel} \PYG{n}{Version}\PYG{p}{:} \PYG{l+m+mf}{4.2}\PYG{o}{.}\PYG{l+m+mi}{0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{27}\PYG{o}{\PYGZhy{}}\PYG{n}{generic}
\PYG{n}{Operating} \PYG{n}{System}\PYG{p}{:} \PYG{n}{Ubuntu} \PYG{l+m+mf}{14.04}\PYG{o}{.}\PYG{l+m+mi}{4} \PYG{n}{LTS}
\PYG{n}{OSType}\PYG{p}{:} \PYG{n}{linux}
\PYG{n}{Architecture}\PYG{p}{:} \PYG{n}{x86\PYGZus{}64}
\PYG{n}{CPUs}\PYG{p}{:} \PYG{l+m+mi}{8}
\PYG{n}{Total} \PYG{n}{Memory}\PYG{p}{:} \PYG{l+m+mf}{15.55}\PYG{n}{GiB}
\PYG{n}{Name}\PYG{p}{:} \PYG{n}{Desktop}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{517}
\PYG{n}{ID}\PYG{p}{:} \PYG{l+m+mi}{6}\PYG{n}{LGK}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{n}{SDD}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{n}{VX4}\PYG{p}{:}\PYG{n}{SFPZ}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{n}{URI}\PYG{p}{:}\PYG{n}{F345}\PYG{p}{:}\PYG{n}{MLU5}\PYG{p}{:}\PYG{n}{RHJC}\PYG{p}{:}\PYG{n}{WCNM}\PYG{p}{:}\PYG{n}{MIWY}\PYG{p}{:}\PYG{n}{WXEB}\PYG{p}{:}\PYG{n}{N6OQ}
\PYG{n}{Docker} \PYG{n}{Root} \PYG{n}{Dir}\PYG{p}{:} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{docker}
\PYG{n}{Debug} \PYG{n}{Mode} \PYG{p}{(}\PYG{n}{client}\PYG{p}{)}\PYG{p}{:} \PYG{n}{false}
\PYG{n}{Debug} \PYG{n}{Mode} \PYG{p}{(}\PYG{n}{server}\PYG{p}{)}\PYG{p}{:} \PYG{n}{false}
\PYG{n}{Registry}\PYG{p}{:} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{index}\PYG{o}{.}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{io}\PYG{o}{/}\PYG{n}{v1}\PYG{o}{/}
\PYG{n}{Labels}\PYG{p}{:}
\PYG{n}{Experimental}\PYG{p}{:} \PYG{n}{false}
\PYG{n}{Insecure} \PYG{n}{Registries}\PYG{p}{:}
 \PYG{l+m+mf}{127.0}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{o}{/}\PYG{l+m+mi}{8}
\PYG{n}{Live} \PYG{n}{Restore} \PYG{n}{Enabled}\PYG{p}{:} \PYG{n}{false}

\PYG{n}{WARNING}\PYG{p}{:} \PYG{n}{No} \PYG{n}{swap} \PYG{n}{limit} \PYG{n}{support}
\end{sphinxVerbatim}
\begin{quote}

说明: 文档中的操作，如无特殊说明，都是在非root用户权限下执行。涉及到 \sphinxcode{\sphinxupquote{sudo}} 操作的，需要输入root用户密码，文档中省略。
\end{quote}


\section{Quick Start}
\label{\detokenize{docker/intro:quick-start}}
这里使用docker官网提供的\sphinxcode{\sphinxupquote{hello-world}}应用为例，介绍docker的基础使用。


\subsection{准备环境}
\label{\detokenize{docker/intro:id10}}
见 {\hyperref[\detokenize{docker/intro:install-and-setup}]{\emph{Install and Setup}}}。


\subsection{镜像}
\label{\detokenize{docker/intro:id11}}\begin{itemize}
\item {} 
下载镜像

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{pull} \PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}
\end{sphinxVerbatim}

执行输出如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Using} \PYG{n}{default} \PYG{n}{tag}\PYG{p}{:} \PYG{n}{latest}
\PYG{n}{latest}\PYG{p}{:} \PYG{n}{Pulling} \PYG{k+kn}{from} \PYG{n+nn}{library}\PYG{o}{/}\PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}
\PYG{l+m+mi}{1}\PYG{n}{b930d010525}\PYG{p}{:} \PYG{n}{Pull} \PYG{n}{complete} 
\PYG{n}{Digest}\PYG{p}{:} \PYG{n}{sha256}\PYG{p}{:}\PYG{l+m+mf}{2557e3}\PYG{n}{c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535}
\PYG{n}{Status}\PYG{p}{:} \PYG{n}{Downloaded} \PYG{n}{newer} \PYG{n}{image} \PYG{k}{for} \PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}\PYG{p}{:}\PYG{n}{latest}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
查看镜像

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{images}
\end{sphinxVerbatim}

镜像下载成功后，执行上述命令，即可输出如下内容:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{REPOSITORY}                               \PYG{n}{TAG}                 \PYG{n}{IMAGE} \PYG{n}{ID}            \PYG{n}{CREATED}             \PYG{n}{SIZE}
\PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}                              \PYG{n}{latest}              \PYG{n}{fce289e99eb9}        \PYG{l+m+mi}{5} \PYG{n}{weeks} \PYG{n}{ago}         \PYG{l+m+mf}{1.84}\PYG{n}{kB}
\end{sphinxVerbatim}


\subsection{容器}
\label{\detokenize{docker/intro:id12}}\begin{itemize}
\item {} 
运行容器

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{run} \PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}
\end{sphinxVerbatim}

执行成功的话，会有如下输出:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the \PYGZdq{}hello\PYGZhy{}world\PYGZdq{} image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 \PYGZdl{} docker run \PYGZhy{}it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get\PYGZhy{}started/
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
查看容器

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{ps} \PYG{o}{\PYGZhy{}}\PYG{n}{a}
\end{sphinxVerbatim}

输出如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONTAINER} \PYG{n}{ID}        \PYG{n}{IMAGE}               \PYG{n}{COMMAND}             \PYG{n}{CREATED}              \PYG{n}{STATUS}                          \PYG{n}{PORTS}               \PYG{n}{NAMES}
\PYG{l+m+mi}{3}\PYG{n}{bd9945585b7}        \PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}         \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/hello}\PYG{l+s+s2}{\PYGZdq{}}            \PYG{n}{About} \PYG{n}{a} \PYG{n}{minute} \PYG{n}{ago}   \PYG{n}{Exited} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{About} \PYG{n}{a} \PYG{n}{minute} \PYG{n}{ago}                       \PYG{n}{musing\PYGZus{}galileo}
\end{sphinxVerbatim}

至此，docker基础环境已准备完成。


\chapter{基本概念}
\label{\detokenize{docker/basic_concept:id1}}\label{\detokenize{docker/basic_concept::doc}}
Docker包括三个基础概念:
\begin{itemize}
\item {} 
镜像(Image)

\item {} 
容器(Container)

\item {} 
仓库(Repository)

\end{itemize}


\section{镜像}
\label{\detokenize{docker/basic_concept:id2}}

\subsection{Docker 镜像}
\label{\detokenize{docker/basic_concept:docker}}
我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。
Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。


\subsection{分层存储}
\label{\detokenize{docker/basic_concept:id3}}
因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。
镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。
分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。


\section{容器}
\label{\detokenize{docker/basic_concept:id4}}
镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。
前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。
按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。
数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。


\section{仓库}
\label{\detokenize{docker/basic_concept:id5}}

\subsection{Docker Registry}
\label{\detokenize{docker/basic_concept:docker-registry}}
镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。
一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。
通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 \textless{}仓库名\textgreater{}:\textless{}标签\textgreater{} 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。
以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:14.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。
仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。


\subsection{Docker Registry 公开服务}
\label{\detokenize{docker/basic_concept:id6}}
Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。
最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。
由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。
国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。


\subsection{私有 Docker Registry}
\label{\detokenize{docker/basic_concept:id7}}
除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。在 私有仓库 一节中，会有进一步的搭建私有 Registry 服务的讲解。
开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。
除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype Nexus。


\chapter{基本操作}
\label{\detokenize{docker/basic_cmd:id1}}\label{\detokenize{docker/basic_cmd::doc}}

\section{镜像}
\label{\detokenize{docker/basic_cmd:id2}}

\subsection{构建}
\label{\detokenize{docker/basic_cmd:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo docker build \PYGZhy{}t \PYGZlt{}image\PYGZus{}name\PYGZgt{}:\PYGZlt{}image\PYGZus{}tag\PYGZgt{} \PYGZlt{}docker\PYGZus{}build\PYGZus{}context\PYGZgt{}

说明:
* image\PYGZus{}name: 镜像名称，例如: photon/probe。如果关联镜像仓库，需要带上仓库地址，例如: http://harbor.yitu.com/photon/probe。
* image\PYGZus{}tag: 镜像tag，用于区分不同的使用场景或者版本等。默认是 latest，不过强制要求以产品版本号设置tag。在使用基础镜像构建产品镜像时，不要使用 latest。
* docker\PYGZus{}build\PYGZus{}context: Docker构建上下文路径，可以使用 . 表示当前路径。在构建Docker镜像时，再详细说明。
\end{sphinxVerbatim}


\subsection{拉取镜像}
\label{\detokenize{docker/basic_cmd:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{pull} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}tag}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\begin{quote}

说明:
\begin{itemize}
\item {} 
image\_name: 镜像名称，如果是非docker默认仓库(https://index.docker.io/v1/)的镜像，需要带上镜像仓库地址。

\item {} 
image\_tag: 镜像tag，默认是 latest，强烈要求使用明确的tag，不要使用 latest。

\end{itemize}
\end{quote}

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{pull} \PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}
\end{sphinxVerbatim}


\subsection{查看镜像列表}
\label{\detokenize{docker/basic_cmd:id5}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{images}
\end{sphinxVerbatim}


\subsection{查看特定镜像}
\label{\detokenize{docker/basic_cmd:id6}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{images} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}name}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{images} \PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}
\end{sphinxVerbatim}


\subsection{查看镜像详情}
\label{\detokenize{docker/basic_cmd:id7}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{inspect} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}tag}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{inspect} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}id}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{inspect} \PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{inspect} \PYG{n}{fce289e99eb9}
\end{sphinxVerbatim}
\begin{quote}

说明: 镜像和容器本地操作中，使用\textless{}image\_name\textgreater{}:\textless{}image\_tag\textgreater{}的地方，均可以使用 \textless{}image\_id\textgreater{} 替代。
\end{quote}


\subsection{删除镜像}
\label{\detokenize{docker/basic_cmd:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{rmi} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}tag}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{rmi} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}id}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{rmi} \PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{rmi} \PYG{n}{fce289e99eb9}
\end{sphinxVerbatim}
\begin{quote}

注意: 删除镜像时，不能有该镜像运行的容器，否则会报错:
Error response from daemon: conflict: unable to delete fce289e99eb9 (must be forced) - image is being used by stopped container 3bd9945585b7
\end{quote}


\subsection{导出镜像}
\label{\detokenize{docker/basic_cmd:id9}}
可以将镜像导出为tar包。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{save} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}tar\PYGZus{}file}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}tag}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

or

使用重定向:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{save} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}tag}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}tar\PYGZus{}file}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\begin{quote}

说明:
\begin{itemize}
\item {} 
image\_tar\_file: 保存的tar文件名称

\item {} 
image\_name: 镜像名称

\item {} 
image\_tag: 镜像tag

\end{itemize}
\end{quote}

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{save} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{n}{hello}\PYG{o}{.}\PYG{n}{tar} \PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world}
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{save} \PYG{n}{hello}\PYG{o}{\PYGZhy{}}\PYG{n}{world} \PYG{o}{\PYGZgt{}} \PYG{n}{hello}\PYG{o}{.}\PYG{n}{tar}
\end{sphinxVerbatim}
\begin{quote}

说明: 亦可使用 \textless{}iamge\_id\textgreater{} 替代 \textless{}image\_name\textgreater{}:\textless{}image\_tag\textgreater{}，但在导入镜像时会丢失tag信息，不建议。
\end{quote}


\subsection{导入镜像}
\label{\detokenize{docker/basic_cmd:id10}}
可以将导出的tar包，导入到本地镜像仓库。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{load} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}tar\PYGZus{}file}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{load} \PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}tar\PYGZus{}file}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\begin{quote}

说明:
\begin{itemize}
\item {} 
image\_tar\_file: 导出的镜像tar文件路径

\end{itemize}
\end{quote}

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{load} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{n}{hello}\PYG{o}{.}\PYG{n}{tar}
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{load} \PYG{o}{\PYGZlt{}} \PYG{n}{hello}\PYG{o}{.}\PYG{n}{tar}
\end{sphinxVerbatim}


\section{容器}
\label{\detokenize{docker/basic_cmd:id11}}

\subsection{启动容器}
\label{\detokenize{docker/basic_cmd:id12}}
可以使用镜像，启动容器。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{run} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{rm} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZlt{}}\PYG{n}{host\PYGZus{}port1}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}port1}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{\PYGZlt{}}\PYG{n}{host\PYGZus{}port2}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}port2}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{\PYGZlt{}}\PYG{n}{host\PYGZus{}volume1}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}volume1}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{\PYGZlt{}}\PYG{n}{host\PYGZus{}volume2}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}volume2}\PYG{o}{\PYGZgt{}}  \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{KEY1}\PYG{o}{=}\PYG{n}{VALUE1} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{KEY2}\PYG{o}{=}\PYG{n}{VALUE2} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{image\PYGZus{}tag}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{args}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\begin{quote}

说明:
\begin{itemize}
\item {} 
启动的主命令是 \sphinxcode{\sphinxupquote{sudo docker run}}

\item {} 
\sphinxcode{\sphinxupquote{-d}}是让容器以守护态运行。相对应的，\sphinxcode{\sphinxupquote{-ti}}是以交互方式运行，即进入容器内部，可以在容器内操作命令。其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。

\item {} 
\sphinxcode{\sphinxupquote{-{-}rm}} 是指在停止容器时(\sphinxcode{\sphinxupquote{sudo docker stop}})，停止成功时，自动删除容器，释放资源。注意: 如果带上该参数，在容器启动失败时，会自动删除失败的容器。如果需要定位问题，将该参数移除。

\item {} 
\sphinxcode{\sphinxupquote{-p}} 参数指定了主机和容器间的端口映射关系，完整的格式应该是 \sphinxcode{\sphinxupquote{\textless{}host\_ip\textgreater{}:\textless{}host\_port\textgreater{}:\textless{}container\_port\textgreater{}/\textless{}protocol\textgreater{}}}。其中，\sphinxcode{\sphinxupquote{host\_ip}}为主机上端口绑定IP，默认为\sphinxcode{\sphinxupquote{0.0.0.0}}；\sphinxcode{\sphinxupquote{host\_port}}为主机上映射的端口，即可在主机上访问容器服务的端口；\sphinxcode{\sphinxupquote{container\_port}}为容器中服务暴露的端口；\sphinxcode{\sphinxupquote{protocol}}为端口协议，TCP或者UDP，默认为TCP。注意: 如果要将容器内的端口与主机端口映射，需要在容器中，将端口绑定在\sphinxcode{\sphinxupquote{0.0.0.0}}上，否则，网络不可达。

\item {} 
\sphinxcode{\sphinxupquote{-p}}参数可以指定多个，即容器中有多个端口需要与主机映射。注意主机上端口冲突。

\item {} 
\sphinxcode{\sphinxupquote{-v}}参数指定了主机和容器间的数据卷挂载，其中，\sphinxcode{\sphinxupquote{host\_volume}}是主机上的文件/目录路径(注意，需是绝对路径)；\sphinxcode{\sphinxupquote{container\_volume}}是容器中的文件/目录。挂载的主机目录的默认权限是\sphinxcode{\sphinxupquote{读写}}。通过数据卷的方式，可以做到数据持久化，在容器销毁时，挂载的数据卷依然保留。另一方面，可以通过数据卷的方式，定制化配置文件。

\item {} 
\sphinxcode{\sphinxupquote{-e}}参数指定了容器运行时的环境变量。对于可变配置，也可以通过环境变量的方式传入。

\item {} 
\sphinxcode{\sphinxupquote{-{-}name}}指定了容器运行的名称，默认容器以随机的方式生成名称。注意: 容器名称要保持唯一，否则会报错。

\item {} 
\sphinxcode{\sphinxupquote{\textless{}image\_name\textgreater{}:\textless{}image\_tag\textgreater{}}}: 容器使用的镜像，亦可以用 \sphinxcode{\sphinxupquote{\textless{}image\_id\textgreater{}}}。

\item {} 
\sphinxcode{\sphinxupquote{args}}启动容器时，传入的参数列表，可选。后续介绍镜像构建时，再做详细介绍。

\end{itemize}
\end{quote}


\subsection{查看容器列表}
\label{\detokenize{docker/basic_cmd:id13}}
查询所有状态的容器:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{ps} \PYG{o}{\PYGZhy{}}\PYG{n}{a}
\end{sphinxVerbatim}

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONTAINER} \PYG{n}{ID}        \PYG{n}{IMAGE}               \PYG{n}{COMMAND}                  \PYG{n}{CREATED}             \PYG{n}{STATUS}              \PYG{n}{PORTS}                      \PYG{n}{NAMES}
\PYG{l+m+mi}{505877}\PYG{n}{bce603}        \PYG{n}{mongo}               \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{docker\PYGZhy{}entrypoint...}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{l+m+mi}{32} \PYG{n}{minutes} \PYG{n}{ago}      \PYG{n}{Up} \PYG{l+m+mi}{32} \PYG{n}{minutes}       \PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{p}{:}\PYG{l+m+mi}{27017}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{27017}\PYG{o}{/}\PYG{n}{tcp}   \PYG{n}{cmdb}\PYG{o}{\PYGZhy{}}\PYG{n}{mongo}
\PYG{n}{d617d6ecfcbc}        \PYG{n}{redis}               \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{docker\PYGZhy{}entrypoint...}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{l+m+mi}{32} \PYG{n}{minutes} \PYG{n}{ago}      \PYG{n}{Up} \PYG{l+m+mi}{32} \PYG{n}{minutes}       \PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{p}{:}\PYG{l+m+mi}{6379}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{6379}\PYG{o}{/}\PYG{n}{tcp}     \PYG{n}{cmdb}\PYG{o}{\PYGZhy{}}\PYG{n}{redis}
\end{sphinxVerbatim}
\begin{quote}

说明:
\begin{itemize}
\item {} 
STATUS: 容器运行状态，\sphinxcode{\sphinxupquote{Up}}表示正常运行，\sphinxcode{\sphinxupquote{Exit}}表示退出，根据退出码判断是否异常退出。

\item {} 
PORTS: 端口映射关系。

\end{itemize}
\end{quote}

查询正在运行的容器:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{ps}
\end{sphinxVerbatim}


\subsection{启动容器}
\label{\detokenize{docker/basic_cmd:id14}}
在容器停止或者异常退出后，可以启动容器。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{start} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}id}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{start} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}name}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\begin{quote}

说明:
\begin{itemize}
\item {} 
container\_id: 容器id

\item {} 
container\_name: 容器名称

\end{itemize}
\end{quote}


\subsection{查看日志}
\label{\detokenize{docker/basic_cmd:id15}}
容器启动后，可以通过查看容器日志。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{logs} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}id}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{logs} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}name}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\begin{quote}

注意: logs查看的是控制台(stdout/stderr)日志。
\end{quote}

如果需要持续输出日志(类似 \sphinxcode{\sphinxupquote{tail -f}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{logs} \PYG{o}{\PYGZhy{}}\PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}id}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{停止容器}
\label{\detokenize{docker/basic_cmd:id16}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{stop} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}id}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{stop} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}name}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{执行命令}
\label{\detokenize{docker/basic_cmd:id17}}
可以在运行中的容器中执行命令。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{exec} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}id}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{cmd\PYGZus{}line}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{exec} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}name}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{cmd\PYGZus{}line}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\begin{quote}

说明:
\begin{itemize}
\item {} 
容器必须是正常运行

\item {} 
\sphinxcode{\sphinxupquote{cmd\_line}}: 命令行

\end{itemize}
\end{quote}

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{exec} \PYG{n}{d617d6ecfcbc} \PYG{n}{cat} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{redis}\PYG{o}{/}\PYG{n}{redis}\PYG{o}{.}\PYG{n}{conf}
\end{sphinxVerbatim}


\subsection{拷贝容器文件}
\label{\detokenize{docker/basic_cmd:id18}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{cp} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}id}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}file\PYGZus{}path}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{host\PYGZus{}file\PYGZus{}path}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{cp} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}name}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}file\PYGZus{}path}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{host\PYGZus{}file\PYGZus{}path}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{查看容器详情}
\label{\detokenize{docker/basic_cmd:id19}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{inspect} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}id}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{inspect} \PYG{o}{\PYGZlt{}}\PYG{n}{container\PYGZus{}name}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\section{仓库}
\label{\detokenize{docker/basic_cmd:id20}}
使用公司内\sphinxhref{https://harbor.yitu-inc.com/harbor/projects}{仓库}。

在镜像构建时，再介绍仓库的交互。


\chapter{实践}
\label{\detokenize{docker/practice:id1}}\label{\detokenize{docker/practice::doc}}

\section{概述}
\label{\detokenize{docker/practice:id2}}
该章节通过两个模拟服务(\sphinxcode{\sphinxupquote{fp-frontend}}和\sphinxcode{\sphinxupquote{fp-backend}})，介绍如何做容器化改造，穿插介绍Docker相关的知识和使用方法，以及如何部署，如何解决服务依赖等。主要包括:
\begin{itemize}
\item {} 
镜像制作(Dockerfile)

\item {} 
镜像管理

\item {} 
容器部署

\item {} 
服务依赖

\item {} 
网络配置

\item {} 
数据持久化

\end{itemize}


\section{准备工作}
\label{\detokenize{docker/practice:id3}}

\subsection{开发环境}
\label{\detokenize{docker/practice:id4}}
由于是从开发态制作镜像，需要准备好开发环境。模拟服务都是使用\sphinxcode{\sphinxupquote{java}}语言开发，基于\sphinxcode{\sphinxupquote{maven}}做依赖包管理。
\begin{itemize}
\item {} 
JDK

\end{itemize}

模拟服务中使用的是 \sphinxcode{\sphinxupquote{1.8.0\_181}} 版本。

从Oracle\sphinxhref{https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html}{官网}下载对应的tar.gz二进制包，在本地解压，配置下JAVA\_HOME即可。
执行\sphinxcode{\sphinxupquote{java -version}}验证。输出如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{java} \PYG{n}{version} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1.8.0\PYGZus{}181}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{Java}\PYG{p}{(}\PYG{n}{TM}\PYG{p}{)} \PYG{n}{SE} \PYG{n}{Runtime} \PYG{n}{Environment} \PYG{p}{(}\PYG{n}{build} \PYG{l+m+mf}{1.8}\PYG{o}{.}\PYG{l+m+mi}{0\PYGZus{}181}\PYG{o}{\PYGZhy{}}\PYG{n}{b13}\PYG{p}{)}
\PYG{n}{Java} \PYG{n}{HotSpot}\PYG{p}{(}\PYG{n}{TM}\PYG{p}{)} \PYG{l+m+mi}{64}\PYG{o}{\PYGZhy{}}\PYG{n}{Bit} \PYG{n}{Server} \PYG{n}{VM} \PYG{p}{(}\PYG{n}{build} \PYG{l+m+mf}{25.181}\PYG{o}{\PYGZhy{}}\PYG{n}{b13}\PYG{p}{,} \PYG{n}{mixed} \PYG{n}{mode}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
maven

\end{itemize}

模拟服务中使用的是\sphinxcode{\sphinxupquote{3.5.4}}版本。

从Apache\sphinxhref{https://maven.apache.org/download.cgi}{官网}下载二进制包，在本地解压，配置M2\_HOME和PATH即可。
执行\sphinxcode{\sphinxupquote{mvn -v}}验证。输出如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Apache} \PYG{n}{Maven} \PYG{l+m+mf}{3.5}\PYG{o}{.}\PYG{l+m+mi}{4} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{edded0938998edf8bf061f1ceb3cfdeccf443fe}\PYG{p}{;} \PYG{l+m+mi}{2018}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{06}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{18}\PYG{n}{T02}\PYG{p}{:}\PYG{l+m+mi}{33}\PYG{p}{:}\PYG{l+m+mi}{14}\PYG{o}{+}\PYG{l+m+mi}{08}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{)}
\PYG{n}{Maven} \PYG{n}{home}\PYG{p}{:} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{llliu}\PYG{o}{/}\PYG{n}{workspace}\PYG{o}{/}\PYG{n}{maven}
\PYG{n}{Java} \PYG{n}{version}\PYG{p}{:} \PYG{l+m+mf}{1.8}\PYG{o}{.}\PYG{l+m+mi}{0\PYGZus{}181}\PYG{p}{,} \PYG{n}{vendor}\PYG{p}{:} \PYG{n}{Oracle} \PYG{n}{Corporation}\PYG{p}{,} \PYG{n}{runtime}\PYG{p}{:} \PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{llliu}\PYG{o}{/}\PYG{n}{workspace}\PYG{o}{/}\PYG{n}{jdk8}\PYG{o}{/}\PYG{n}{jre}
\PYG{n}{Default} \PYG{n}{locale}\PYG{p}{:} \PYG{n}{en\PYGZus{}US}\PYG{p}{,} \PYG{n}{platform} \PYG{n}{encoding}\PYG{p}{:} \PYG{n}{UTF}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}
\PYG{n}{OS} \PYG{n}{name}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linux}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{version}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4.15.0\PYGZhy{}33\PYGZhy{}generic}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{arch}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{amd64}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{family}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{unix}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

使用的maven仓库是阿里云的，仓库地址配置如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{mirrors}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{n}{mirror}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n+nb}{id}\PYG{o}{\PYGZgt{}}\PYG{n}{nexus}\PYG{o}{\PYGZhy{}}\PYG{n}{aliyun}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{id}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{mirrorOf}\PYG{o}{\PYGZgt{}}\PYG{n}{central}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{mirrorOf}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{name}\PYG{o}{\PYGZgt{}}\PYG{n}{Nexus} \PYG{n}{aliyun}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{name}\PYG{o}{\PYGZgt{}}
        \PYG{o}{\PYGZlt{}}\PYG{n}{url}\PYG{o}{\PYGZgt{}}\PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{maven}\PYG{o}{.}\PYG{n}{aliyun}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{nexus}\PYG{o}{/}\PYG{n}{content}\PYG{o}{/}\PYG{n}{groups}\PYG{o}{/}\PYG{n}{public}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{url}\PYG{o}{\PYGZgt{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{mirror}\PYG{o}{\PYGZgt{}}
  \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{mirrors}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

将上述配置增加至 \sphinxcode{\sphinxupquote{\$M2\_HOME/conf/settings.xml}} 中。


\subsection{开发工程}
\label{\detokenize{docker/practice:id5}}\begin{itemize}
\item {} 
\sphinxhref{http://gitlab.yitu-inc.com/devops/observability/fp-frontend}{fp-frontend}

\item {} 
\sphinxhref{http://gitlab.yitu-inc.com/devops/observability/fp-backend}{fp-backend}

\end{itemize}


\section{镜像}
\label{\detokenize{docker/practice:id6}}
该章节介绍如何制作Docker镜像和镜像管理。


\subsection{制作镜像}
\label{\detokenize{docker/practice:id7}}
在基本概念中介绍过，Docker镜像其实是一个特殊的文件系统，采用分层结构存储，是一组文件系统的组合。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。

所以，制作镜像的过程，就是在编排如何修改、增加文件或者配置，形成一个新的文件层。将这些编排动作写入一个脚本，这个脚本就是\sphinxcode{\sphinxupquote{Dockerfile}}。

Dockerfile 是一个文本文件，其内包含了一条条的\sphinxcode{\sphinxupquote{指令(Instruction)}}，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。


\subsubsection{基础镜像}
\label{\detokenize{docker/practice:id8}}
既然是定制文件系统，自然就需要有个root fs，这个root fs就是基础镜像。基础镜像的引入是通过\sphinxcode{\sphinxupquote{FROM}}指令。因此，一个\sphinxcode{\sphinxupquote{Dockerfile}}中，必须有\sphinxcode{\sphinxupquote{FROM}}指令，而且必须是第一条指令。

在\sphinxhref{https://hub.docker.com/}{docker hub}镜像仓库中，有很多基础镜像，例如  \sphinxcode{\sphinxupquote{nginx}}，\sphinxcode{\sphinxupquote{nodejs}}，\sphinxcode{\sphinxupquote{ubuntu}}。在\sphinxcode{\sphinxupquote{Dockerfile}}中通过\sphinxcode{\sphinxupquote{FROM \textless{}image\_name\textgreater{}:\textless{}image\_tag\textgreater{}}}指令即可引用基础镜像。例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FROM} \PYG{n}{ubuntu}\PYG{p}{:}\PYG{l+m+mf}{14.04}
\end{sphinxVerbatim}

其中，\sphinxcode{\sphinxupquote{ubuntu}}是镜像名称(image\_name)，\sphinxcode{\sphinxupquote{14.04}}是镜像tag(image\_tag)。
\begin{quote}

说明: 引用基础镜像时，必须带上 \sphinxcode{\sphinxupquote{image\_tag}}，不得使用 \sphinxcode{\sphinxupquote{latest}}，防止在重复构建时，基础镜像变更导致构建的版本差异。
\end{quote}

下面，来构建第一个镜像。
\begin{itemize}
\item {} 
首先，在工程跟目录下创建\sphinxcode{\sphinxupquote{Dockerfile}}文件。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 以 fp\PYGZus{}frontend　工程为例}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 进入工程根目录}
\PYG{n}{cd} \PYG{n}{fp\PYGZus{}frontend}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 创建Dockerfile文件}
\PYG{n}{touch} \PYG{n}{Dockerfile}
\end{sphinxVerbatim}

\item {} 
编辑\sphinxcode{\sphinxupquote{Dockerfile}}，增加基础镜像。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 编辑文件}
\PYG{n}{vim} \PYG{n}{Dockerfile}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 增加基础镜像}
\PYG{n}{FROM} \PYG{n}{ubuntu}\PYG{p}{:}\PYG{l+m+mf}{14.04}
\end{sphinxVerbatim}

\item {} 
接着，增加一层操作。如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 执行shell命令(暂先不管RUN指令，后面会介绍)}
\PYG{n}{RUN} \PYG{n}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my first docker image.}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\item {} 
退出，保存\sphinxcode{\sphinxupquote{Dockerfile}}。

\item {} 
构建镜像。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{demo}\PYG{o}{\PYGZhy{}}\PYG{n}{image}\PYG{p}{:}\PYG{l+m+mf}{0.1} \PYG{o}{.}
\end{sphinxVerbatim}

输出如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Sending} \PYG{n}{build} \PYG{n}{context} \PYG{n}{to} \PYG{n}{Docker} \PYG{n}{daemon} \PYG{l+m+mf}{516.6} \PYG{n}{kB}
\PYG{n}{Step} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{p}{:} \PYG{n}{FROM} \PYG{n}{ubuntu}\PYG{p}{:}\PYG{l+m+mf}{14.04}
\PYG{l+m+mf}{14.04}\PYG{p}{:} \PYG{n}{Pulling} \PYG{k+kn}{from} \PYG{n+nn}{library}\PYG{o}{/}\PYG{n}{ubuntu}
\PYG{n}{e53f134edff2}\PYG{p}{:} \PYG{n}{Pull} \PYG{n}{complete} 
\PYG{n}{efbbd466a715}\PYG{p}{:} \PYG{n}{Pull} \PYG{n}{complete} 
\PYG{n}{e11368b8e0c7}\PYG{p}{:} \PYG{n}{Pull} \PYG{n}{complete} 
\PYG{l+m+mi}{7}\PYG{n}{dab2de7692b}\PYG{p}{:} \PYG{n}{Pull} \PYG{n}{complete} 
\PYG{n}{Digest}\PYG{p}{:} \PYG{n}{sha256}\PYG{p}{:}\PYG{n}{cac55e5d97fad634d954d00a5c2a56d80576a08dcc01036011f26b88263f1578}
\PYG{n}{Status}\PYG{p}{:} \PYG{n}{Downloaded} \PYG{n}{newer} \PYG{n}{image} \PYG{k}{for} \PYG{n}{ubuntu}\PYG{p}{:}\PYG{l+m+mf}{14.04}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5}\PYG{n}{dbc3f318ea5}
\PYG{n}{Step} \PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{p}{:} \PYG{n}{RUN} \PYG{n}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my first docker image.}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Running} \PYG{o+ow}{in} \PYG{n}{b5f02ed2d89a}
\PYG{n}{my} \PYG{n}{first} \PYG{n}{docker} \PYG{n}{image}\PYG{o}{.}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{d66c9accb323}
\PYG{n}{Removing} \PYG{n}{intermediate} \PYG{n}{container} \PYG{n}{b5f02ed2d89a}
\PYG{n}{Successfully} \PYG{n}{built} \PYG{n}{d66c9accb323}
\end{sphinxVerbatim}

\item {} 
查看镜像

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{images}
\end{sphinxVerbatim}

应该会有刚构建的镜像，以及引入的基础镜像，如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{REPOSITORY}                                      \PYG{n}{TAG}                 \PYG{n}{IMAGE} \PYG{n}{ID}            \PYG{n}{CREATED}             \PYG{n}{SIZE}
\PYG{n}{demo}\PYG{o}{\PYGZhy{}}\PYG{n}{image}                                      \PYG{l+m+mf}{0.1}                 \PYG{n}{d66c9accb323}        \PYG{l+m+mi}{55} \PYG{n}{seconds} \PYG{n}{ago}      \PYG{l+m+mi}{188} \PYG{n}{MB}
\PYG{n}{ubuntu}                                          \PYG{l+m+mf}{14.04}               \PYG{l+m+mi}{5}\PYG{n}{dbc3f318ea5}        \PYG{l+m+mi}{2} \PYG{n}{weeks} \PYG{n}{ago}         \PYG{l+m+mi}{188} \PYG{n}{MB}
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{构建上下文(build context)}
\label{\detokenize{docker/practice:build-context}}
上述构建镜像命令—\sphinxcode{\sphinxupquote{sudo docker build -t demo-image:0.1 .}}，其中\sphinxcode{\sphinxupquote{.}}表示当前目录，但是并不是指的是\sphinxcode{\sphinxupquote{Dockerfile}}所在的目录，而是指定的构建\sphinxcode{\sphinxupquote{上下文路径}}。

首先我们要理解 \sphinxcode{\sphinxupquote{docker build}} 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。

当我们进行镜像构建的时候，并非所有定制都会通过 \sphinxcode{\sphinxupquote{RUN}} 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 \sphinxcode{\sphinxupquote{COPY}} 指令、\sphinxcode{\sphinxupquote{ADD}} 指令等。而 \sphinxcode{\sphinxupquote{docker build}} 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？

这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，\sphinxcode{\sphinxupquote{docker build}} 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。

例如上述例子中，将\sphinxcode{\sphinxupquote{Dockerfile}}拷贝至子目录中(test)，增加\sphinxcode{\sphinxupquote{COPY ../pom.xml /tmp}}指令，执行\sphinxcode{\sphinxupquote{sudo docker build -t demo-image:0.2 test}}时，会发现报错:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Sending} \PYG{n}{build} \PYG{n}{context} \PYG{n}{to} \PYG{n}{Docker} \PYG{n}{daemon} \PYG{l+m+mf}{2.048} \PYG{n}{kB}
\PYG{n}{Step} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{p}{:} \PYG{n}{FROM} \PYG{n}{ubuntu}\PYG{p}{:}\PYG{l+m+mf}{14.04}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5}\PYG{n}{dbc3f318ea5}
\PYG{n}{Step} \PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{p}{:} \PYG{n}{RUN} \PYG{n}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my first docker image.}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Using} \PYG{n}{cache}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{15}\PYG{n}{cbd1708462}
\PYG{n}{Step} \PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{p}{:} \PYG{n}{COPY} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{n}{pom}\PYG{o}{.}\PYG{n}{xml} \PYG{o}{/}\PYG{n}{tmp}
\PYG{n}{Forbidden} \PYG{n}{path} \PYG{n}{outside} \PYG{n}{the} \PYG{n}{build} \PYG{n}{context}\PYG{p}{:} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{n}{pom}\PYG{o}{.}\PYG{n}{xml} \PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

从中也可以看出，\sphinxcode{\sphinxupquote{test}}目录即是构建上下文，\sphinxcode{\sphinxupquote{COPY}}指令的源文件只能是相对于\sphinxcode{\sphinxupquote{test}}目录的，不能超出该目录。

那么为什么会有人误以为 \sphinxcode{\sphinxupquote{.}} 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。

这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 \sphinxcode{\sphinxupquote{-f}}  参数指定某个文件作为 Dockerfile。例如: \sphinxcode{\sphinxupquote{sudo docker build -t demo-image:0.2 test/Dockerfile .}}(使用test目录下的Dockerfile，但构建上下文是在当前目录)。

当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。

上面提到\sphinxcode{\sphinxupquote{docker build}}时，会将构建上下文中的文件打包上传给Docker引擎。那如果当前有些文件不是构建需要的(尤其大文件，影响构建效率)，就可以使用\sphinxcode{\sphinxupquote{.dockerignore}}(类似\sphinxcode{\sphinxupquote{.gitignore}})排除不需要的文件。
例如，创建\sphinxcode{\sphinxupquote{.dockerignore}}，并增加\sphinxcode{\sphinxupquote{pom.xml}}(执行\sphinxcode{\sphinxupquote{echo pom.xml \textgreater{} .dockerignore}})。再次执行\sphinxcode{\sphinxupquote{sudo docker build -t demo-image:0.2 .}}时，会报错:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Sending} \PYG{n}{build} \PYG{n}{context} \PYG{n}{to} \PYG{n}{Docker} \PYG{n}{daemon} \PYG{l+m+mf}{514.6} \PYG{n}{kB}
\PYG{n}{Step} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{p}{:} \PYG{n}{FROM} \PYG{n}{ubuntu}\PYG{p}{:}\PYG{l+m+mf}{14.04}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5}\PYG{n}{dbc3f318ea5}
\PYG{n}{Step} \PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{p}{:} \PYG{n}{RUN} \PYG{n}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{my first docker image.}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Using} \PYG{n}{cache}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{15}\PYG{n}{cbd1708462}
\PYG{n}{Step} \PYG{l+m+mi}{3}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{p}{:} \PYG{n}{COPY} \PYG{n}{pom}\PYG{o}{.}\PYG{n}{xml} \PYG{o}{/}\PYG{n}{app}
\PYG{n}{lstat} \PYG{n}{pom}\PYG{o}{.}\PYG{n}{xml}\PYG{p}{:} \PYG{n}{no} \PYG{n}{such} \PYG{n}{file} \PYG{o+ow}{or} \PYG{n}{directory}
\end{sphinxVerbatim}


\subsubsection{Dockerfile指令}
\label{\detokenize{docker/practice:dockerfile}}
除了引入基础镜像的\sphinxcode{\sphinxupquote{FROM}}，还有一些常用的指令:
\begin{itemize}
\item {} 
RUN

\sphinxcode{\sphinxupquote{RUN}}是用来执行命令行的，有两种格式:
\begin{itemize}
\item {} 
shell格式: \sphinxcode{\sphinxupquote{RUN \textless{}命令\textgreater{}}}，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。

\item {} 
exec 格式：\sphinxcode{\sphinxupquote{RUN {[}"可执行文件", "参数1", "参数2"{]}}}，这更像是函数调用中的格式。

\end{itemize}

\sphinxcode{\sphinxupquote{RUN}}是最常用的指令，例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{update}
\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{gcc} \PYG{n}{libc6}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYG{n}{make} \PYG{n}{wget}
\PYG{n}{RUN} \PYG{n}{wget} \PYG{o}{\PYGZhy{}}\PYG{n}{O} \PYG{n}{redis}\PYG{o}{.}\PYG{n}{tar}\PYG{o}{.}\PYG{n}{gz} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{http://download.redis.io/releases/redis\PYGZhy{}5.0.3.tar.gz}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{RUN} \PYG{n}{mkdir} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{redis}
\PYG{n}{RUN} \PYG{n}{tar} \PYG{o}{\PYGZhy{}}\PYG{n}{xzf} \PYG{n}{redis}\PYG{o}{.}\PYG{n}{tar}\PYG{o}{.}\PYG{n}{gz} \PYG{o}{\PYGZhy{}}\PYG{n}{C} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{redis} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{strip}\PYG{o}{\PYGZhy{}}\PYG{n}{components}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{RUN} \PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{C} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{redis}
\PYG{n}{RUN} \PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{C} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{redis} \PYG{n}{install}
\end{sphinxVerbatim}

按照之前所说，\sphinxcode{\sphinxupquote{Dockerfile}}中每执行一条指令，就会建立一层。像上面，执行构建时，就会产生７层镜像，这样往往会使得镜像非常臃肿、非常多层，不仅增加了构建时间，还增大了出错概率。

Union FS 是有最大层数限制的，比如 AUFS，是不得超过 127 层。

像上面的情况，应该做命令合并，如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
FROM debian:stretch

RUN buildDeps=\PYGZsq{}gcc libc6\PYGZhy{}dev make wget\PYGZsq{} \PYGZbs{}
    \PYGZam{}\PYGZam{} apt\PYGZhy{}get update \PYGZbs{}
    \PYGZam{}\PYGZam{} apt\PYGZhy{}get install \PYGZhy{}y \PYGZdl{}buildDeps \PYGZbs{}
    \PYGZam{}\PYGZam{} wget \PYGZhy{}O redis.tar.gz \PYGZdq{}http://download.redis.io/releases/redis\PYGZhy{}5.0.3.tar.gz\PYGZdq{} \PYGZbs{}
    \PYGZam{}\PYGZam{} mkdir \PYGZhy{}p /usr/src/redis \PYGZbs{}
    \PYGZam{}\PYGZam{} tar \PYGZhy{}xzf redis.tar.gz \PYGZhy{}C /usr/src/redis \PYGZhy{}\PYGZhy{}strip\PYGZhy{}components=1 \PYGZbs{}
    \PYGZam{}\PYGZam{} make \PYGZhy{}C /usr/src/redis \PYGZbs{}
    \PYGZam{}\PYGZam{} make \PYGZhy{}C /usr/src/redis install \PYGZbs{}
    \PYGZam{}\PYGZam{} rm \PYGZhy{}rf /var/lib/apt/lists/* \PYGZbs{}
    \PYGZam{}\PYGZam{} rm redis.tar.gz \PYGZbs{}
    \PYGZam{}\PYGZam{} rm \PYGZhy{}r /usr/src/redis \PYGZbs{}
    \PYGZam{}\PYGZam{} apt\PYGZhy{}get purge \PYGZhy{}y \PYGZhy{}\PYGZhy{}auto\PYGZhy{}remove \PYGZdl{}buildDeps
\end{sphinxVerbatim}

首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 \&\& 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。

并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \textbackslash{} 的命令换行方式，以及行首 \# 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。

此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。

\item {} 
COPY

\sphinxcode{\sphinxupquote{COPY}}指令将构建上下文目录中的 \sphinxcode{\sphinxupquote{\textless{}源路径\textgreater{}}}的文件/目录复制到新的一层的镜像内的 \sphinxcode{\sphinxupquote{\textless{}目标路径\textgreater{}}}。格式为:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{COPY} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{chown}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{user}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{n}{group}\PYG{o}{\PYGZgt{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{源路径}\PYG{o}{\PYGZgt{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{o}{\PYGZlt{}}\PYG{n}{目标路径}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\begin{quote}

注意: 源文件一定是在构建上下文下，所以必须是相对路径。
\end{quote}

比如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{COPY} \PYG{n}{target}\PYG{o}{/}\PYG{n}{fp}\PYG{o}{\PYGZhy{}}\PYG{n}{frontend}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mf}{1.}\PYG{n}{jar} \PYG{o}{/}\PYG{n}{app}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{\textless{}源路径\textgreater{}}}可以是多个，甚至可以是通配符，例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
COPY hom* /mydir/
COPY hom?.txt /mydir/
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{\textless{}目标路径\textgreater{}}} 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。

此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。

在使用该指令的时候还可以加上\sphinxcode{\sphinxupquote{-{-}chown=\textless{}user\textgreater{}:\textless{}group\textgreater{}}}选项来改变文件的所属用户及所属组。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{COPY} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{chown}\PYG{o}{=}\PYG{l+m+mi}{55}\PYG{p}{:}\PYG{n}{mygroup} \PYG{n}{files}\PYG{o}{*} \PYG{o}{/}\PYG{n}{mydir}\PYG{o}{/}
\PYG{n}{COPY} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{chown}\PYG{o}{=}\PYG{n+nb}{bin} \PYG{n}{files}\PYG{o}{*} \PYG{o}{/}\PYG{n}{mydir}\PYG{o}{/}
\PYG{n}{COPY} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{chown}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{n}{files}\PYG{o}{*} \PYG{o}{/}\PYG{n}{mydir}\PYG{o}{/}
\PYG{n}{COPY} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{chown}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{11} \PYG{n}{files}\PYG{o}{*} \PYG{o}{/}\PYG{n}{mydir}\PYG{o}{/}
\end{sphinxVerbatim}

\item {} 
ADD

\sphinxcode{\sphinxupquote{ADD}} 指令和 \sphinxcode{\sphinxupquote{COPY}} 的格式和性质基本一致。但是在 \sphinxcode{\sphinxupquote{COPY}} 基础上增加了一些功能。

比如 \sphinxcode{\sphinxupquote{\textless{}源路径\textgreater{}}} 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 \sphinxcode{\sphinxupquote{\textless{}目标路径\textgreater{}}} 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 \sphinxcode{\sphinxupquote{RUN}} 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 \sphinxcode{\sphinxupquote{RUN}} 指令进行解压缩。所以不如直接使用 \sphinxcode{\sphinxupquote{RUN}} 指令，然后使用 \sphinxcode{\sphinxupquote{wget}} 或者 \sphinxcode{\sphinxupquote{curl}} 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。

如果 \sphinxcode{\sphinxupquote{\textless{}源路径\textgreater{}}} 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，\sphinxcode{\sphinxupquote{ADD}} 指令将会自动解压缩这个压缩文件到 \sphinxcode{\sphinxupquote{\textless{}目标路径\textgreater{}}} 去。

\sphinxcode{\sphinxupquote{ADD}}指令相比于\sphinxcode{\sphinxupquote{COPY}}会包含更复杂的功能，但\sphinxcode{\sphinxupquote{COPY}}的语义更明确，所以，尽可能使用\sphinxcode{\sphinxupquote{COPY}}。\sphinxcode{\sphinxupquote{ADD}}的最适合的场景，就是上述提及的需要自动解压的场合。另外需要注意的是，\sphinxcode{\sphinxupquote{ADD}} 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。

在使用该指令的时候还可以加上 \sphinxcode{\sphinxupquote{-{-}chown=\textless{}user\textgreater{}:\textless{}group\textgreater{}}} 选项来改变文件的所属用户及所属组。

\item {} 
CMD

\sphinxcode{\sphinxupquote{CMD}}用来指定容器的启动命令，指令格式和\sphinxcode{\sphinxupquote{RUN}}类似，有两种格式:
\begin{itemize}
\item {} 
shell格式: \sphinxcode{\sphinxupquote{CMD \textless{}命令\textgreater{}}}

\item {} 
exec格式: \sphinxcode{\sphinxupquote{CMD {[}"可执行文件", "参数1", "参数2"....{]}}}

\item {} 
参数列表格式: \sphinxcode{\sphinxupquote{CMD {[}"参数1", "参数2"...{]}}}。在指定了 \sphinxcode{\sphinxupquote{ENTRYPOINT}} 指令后，用\sphinxcode{\sphinxupquote{CMD}} 指定具体的参数。

\end{itemize}

之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。在运行时可以指定新的命令来替代镜像设置中的这个默认命令。

在指令格式上，一般推荐使用 \sphinxcode{\sphinxupquote{exec}} 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 \sphinxcode{\sphinxupquote{"}}，而不要使用单引号。

如果使用 shell 格式的话，实际的命令会被包装为 \sphinxcode{\sphinxupquote{sh -c}} 的参数的形式进行执行。比如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CMD echo \PYGZdl{}HOME
\end{sphinxVerbatim}

在实际执行中，会将其变更为：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CMD} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sh}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{echo \PYGZdl{}HOME}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}
\end{sphinxVerbatim}

这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。

使用\sphinxcode{\sphinxupquote{CMD}}，需要特别注意容器中应用在前台执行和后台执行的问题。

Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。

比如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CMD} \PYG{n}{service} \PYG{n}{nginx} \PYG{n}{start}
\end{sphinxVerbatim}

发现通过上述的方式启动nginx的化，在通过\sphinxcode{\sphinxupquote{sudo docker run}}启动容器时，执行完成后，容器就退出了。甚至在容器中使用\sphinxcode{\sphinxupquote{systemctl}}命令结果却根本无法执行。

对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。

而使用 \sphinxcode{\sphinxupquote{service nginx start}} 命令，则是希望 \sphinxcode{\sphinxupquote{upstart}} 来以后台守护进程形式启动 \sphinxcode{\sphinxupquote{nginx}} 服务。而刚才说了 \sphinxcode{\sphinxupquote{CMD service nginx start}} 会被理解为 \sphinxcode{\sphinxupquote{CMD {[} "sh", "-c", "service nginx start"{]}}}，因此主进程实际上是 sh。那么当 \sphinxcode{\sphinxupquote{service nginx start}} 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。

正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CMD} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nginx}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}g}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{daemon off;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
ENTRYPOINT

\sphinxcode{\sphinxupquote{ENTRYPOINT}} 的目的和 \sphinxcode{\sphinxupquote{CMD}} 一样，都是在指定容器启动程序及参数。\sphinxcode{\sphinxupquote{ENTRYPOINT}} 在运行时也可以替代，不过比 \sphinxcode{\sphinxupquote{CMD}} 要略显繁琐，需要通过 \sphinxcode{\sphinxupquote{docker run}} 的参数\sphinxcode{\sphinxupquote{-{-}entrypoint}} 来指定。

当指定了 \sphinxcode{\sphinxupquote{ENTRYPOINT}} 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 \sphinxcode{\sphinxupquote{CMD}} 的内容作为参数传给 \sphinxcode{\sphinxupquote{ENTRYPOINT}} 指令，换句话说实际执行时，将变为：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{ENTRYPOINT}\PYG{o}{\PYGZgt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}CMD\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

那相比于\sphinxcode{\sphinxupquote{CMD}}，\sphinxcode{\sphinxupquote{ENTRYPOINT}}有什么好处呢？
\begin{itemize}
\item {} 
场景一: 让镜像变得像命令一样使用
假设我们需要一个得知自己当前公网IP的镜像，用\sphinxcode{\sphinxupquote{CMD}}实现:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FROM} \PYG{n}{ubuntu}\PYG{p}{:}\PYG{l+m+mf}{18.04}
\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{update} \PYGZbs{}
    \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{curl} \PYGZbs{}
    \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rm} \PYG{o}{\PYGZhy{}}\PYG{n}{rf} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{apt}\PYG{o}{/}\PYG{n}{lists}\PYG{o}{/}\PYG{o}{*}
\PYG{n}{CMD} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{curl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}s}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{https://ip.cn}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}
\end{sphinxVerbatim}

执行\sphinxcode{\sphinxupquote{sudo docker build -t myip:0.1 .}}构建镜像。如果需要查询当前公网IP，只需要执行:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{run} \PYG{n}{myip}\PYG{p}{:}\PYG{l+m+mf}{0.1}
\end{sphinxVerbatim}

就可以得到如下结果:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{当前} \PYG{n}{IP}\PYG{p}{:} \PYG{l+m+mf}{103.59}\PYG{o}{.}\PYG{l+m+mf}{48.21} \PYG{n}{来自}\PYG{p}{:} \PYG{n}{香港特别行政区}
\end{sphinxVerbatim}

但，在启动时传递参数时，如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{run} \PYG{n}{myip}\PYG{p}{:}\PYG{l+m+mf}{0.1} \PYG{o}{\PYGZhy{}}\PYG{n}{i}
\end{sphinxVerbatim}

结果却是:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{container\PYGZus{}linux}\PYG{o}{.}\PYG{n}{go}\PYG{p}{:}\PYG{l+m+mi}{247}\PYG{p}{:} \PYG{n}{starting} \PYG{n}{container} \PYG{n}{process} \PYG{n}{caused} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{exec: }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}i}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s2}{: executable file not found in \PYGZdl{}PATH}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{docker}\PYG{p}{:} \PYG{n}{Error} \PYG{n}{response} \PYG{k+kn}{from} \PYG{n+nn}{daemon}\PYG{p}{:} \PYG{n}{oci} \PYG{n}{runtime} \PYG{n}{error}\PYG{p}{:} \PYG{n}{container\PYGZus{}linux}\PYG{o}{.}\PYG{n}{go}\PYG{p}{:}\PYG{l+m+mi}{247}\PYG{p}{:} \PYG{n}{starting} \PYG{n}{container} \PYG{n}{process} \PYG{n}{caused} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{exec: }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}i}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s2}{: executable file not found in \PYGZdl{}PATH}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}
\PYG{n}{ERRO}\PYG{p}{[}\PYG{l+m+mi}{0000}\PYG{p}{]} \PYG{n}{error} \PYG{n}{getting} \PYG{n}{events} \PYG{k+kn}{from} \PYG{n+nn}{daemon}\PYG{p}{:} \PYG{n}{net}\PYG{o}{/}\PYG{n}{http}\PYG{p}{:} \PYG{n}{request} \PYG{n}{canceled}
\end{sphinxVerbatim}

之前说过，如果是\sphinxcode{\sphinxupquote{CMD}}，启动容器时传递的参数，会替换\sphinxcode{\sphinxupquote{CMD}}的默认值，也就是上述执行的是\sphinxcode{\sphinxupquote{sh -c -i}}，并不是预期的\sphinxcode{\sphinxupquote{sh -c curl -s https://ip.cn -i}}。

而使用\sphinxcode{\sphinxupquote{ENTRYPOINT}}就可以解决这个问题，可以将上述\sphinxcode{\sphinxupquote{Dockerfile}}中\sphinxcode{\sphinxupquote{CMD}}替换成\sphinxcode{\sphinxupquote{ENTRYPOINT}}，重新构建，验证下。
\begin{itemize}
\item {} 
场景二: 应用运行前的准备工作

\end{itemize}

启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。

比如，在实际场景中，会避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。

这些预备动作，就可以写一个脚本，然后放到\sphinxcode{\sphinxupquote{ENTRYPOINT}}中去执行，而把脚本将要接收到的参数(即\sphinxcode{\sphinxupquote{CMD}}指定的命令)作为命令，在脚本最后执行。例如，官网的\sphinxcode{\sphinxupquote{redis}} 镜像就是这么做的:

Dockerfile:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FROM} \PYG{n}{alpine}\PYG{p}{:}\PYG{l+m+mf}{3.4}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{RUN} \PYG{n}{addgroup} \PYG{o}{\PYGZhy{}}\PYG{n}{S} \PYG{n}{redis} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{adduser} \PYG{o}{\PYGZhy{}}\PYG{n}{S} \PYG{o}{\PYGZhy{}}\PYG{n}{G} \PYG{n}{redis} \PYG{n}{redis}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{ENTRYPOINT} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{docker\PYGZhy{}entrypoint.sh}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

\PYG{n}{EXPOSE} \PYG{l+m+mi}{6379}
\PYG{n}{CMD} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{redis\PYGZhy{}server}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}
\end{sphinxVerbatim}

docker-entrypoint.sh:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{c+c1}{\PYGZsh{} allow the container to be started with {}`\PYGZhy{}\PYGZhy{}user{}`}
\PYG{k}{if} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{redis\PYGZhy{}server}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}(id \PYGZhy{}u)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}\PYG{p}{;} \PYG{n}{then}
    \PYG{n}{chown} \PYG{o}{\PYGZhy{}}\PYG{n}{R} \PYG{n}{redis} \PYG{o}{.}
    \PYG{n}{exec} \PYG{n}{su}\PYG{o}{\PYGZhy{}}\PYG{n}{exec} \PYG{n}{redis} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}@}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{fi}

\PYG{n}{exec} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}@}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

脚本的内容是根据传入的参数(即\sphinxcode{\sphinxupquote{CMD}}指定的)来判断，如果是\sphinxcode{\sphinxupquote{redis-server}}，则切换到\sphinxcode{\sphinxupquote{redis}}用户下执行启动服务器；否则以\sphinxcode{\sphinxupquote{root}}用户，执行\sphinxcode{\sphinxupquote{CMD}}指定的命令。

那么，如果是\sphinxcode{\sphinxupquote{sudo docker run -it redis id}}，\sphinxcode{\sphinxupquote{CMD}}被替换为\sphinxcode{\sphinxupquote{id}}，会使用\sphinxcode{\sphinxupquote{root}}用户执行\sphinxcode{\sphinxupquote{id}}命令，输出如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{uid}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)} \PYG{n}{gid}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)} \PYG{n}{groups}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
ENV

\sphinxcode{\sphinxupquote{ENV}}用来设置环境变量。格式为:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ENV \textless{}key\textgreater{} \textless{}value\textgreater{}}}

\item {} 
\sphinxcode{\sphinxupquote{ENV \textless{}key1\textgreater{}=\textless{}value1\textgreater{} \textless{}key2\textgreater{}=\textless{}value2\textgreater{}...}}

\end{itemize}

设置环境变量后，在\sphinxcode{\sphinxupquote{ENV}}后续的指令，或者运行时的应用，都可以使用该环境变量。

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
FROM ubuntu:14.04
ENV profile=test
RUN echo \PYGZdl{}profile
\end{sphinxVerbatim}

执行构建\sphinxcode{\sphinxupquote{sudo docker build -t env-test:0.1 .}}，构建中会输出\sphinxcode{\sphinxupquote{test}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Sending build context to Docker daemon 514.6 kB
Step 1/3 : FROM ubuntu:14.04
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 5dbc3f318ea5
Step 2/3 : ENV profile test
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Running in 9c4971f4c0e7
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 172ff378ada8
Removing intermediate container 9c4971f4c0e7
Step 3/3 : RUN echo \PYGZdl{}profile
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Running in 7e6cde357417
test
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 6c93c2ef1e4b
Removing intermediate container 7e6cde357417
Successfully built 6c93c2ef1e4b
\end{sphinxVerbatim}

通过交互方式进入容器\sphinxcode{\sphinxupquote{sudo docker run -ti env-test:0.1 bash}}，执行:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{root}\PYG{n+nd}{@57bd9be6fb61}\PYG{p}{:}\PYG{o}{/}\PYG{c+c1}{\PYGZsh{} echo \PYGZdl{}profile}
\PYG{n}{test}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{ENV}}也可以用来作为可变参数，比如官网的\sphinxcode{\sphinxupquote{node}}镜像:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ENV} \PYG{n}{NODE\PYGZus{}VERSION} \PYG{l+m+mf}{7.2}\PYG{o}{.}\PYG{l+m+mi}{0}

\PYG{n}{RUN} \PYG{n}{curl} \PYG{o}{\PYGZhy{}}\PYG{n}{SLO} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{https://nodejs.org/dist/v\PYGZdl{}NODE\PYGZus{}VERSION/node\PYGZhy{}v\PYGZdl{}NODE\PYGZus{}VERSION\PYGZhy{}linux\PYGZhy{}x64.tar.xz}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
  \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{curl} \PYG{o}{\PYGZhy{}}\PYG{n}{SLO} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{https://nodejs.org/dist/v\PYGZdl{}NODE\PYGZus{}VERSION/SHASUMS256.txt.asc}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
  \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{gpg} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{batch} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{decrypt} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{output} \PYG{n}{SHASUMS256}\PYG{o}{.}\PYG{n}{txt} \PYG{n}{SHASUMS256}\PYG{o}{.}\PYG{n}{txt}\PYG{o}{.}\PYG{n}{asc} \PYGZbs{}
  \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{grep} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ node\PYGZhy{}v\PYGZdl{}NODE\PYGZus{}VERSION\PYGZhy{}linux\PYGZhy{}x64.tar.xz}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{SHASUMS256}\PYG{o}{.}\PYG{n}{txt} \PYG{o}{\textbar{}} \PYG{n}{sha256sum} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{o}{\PYGZhy{}} \PYGZbs{}
  \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{tar} \PYG{o}{\PYGZhy{}}\PYG{n}{xJf} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{node\PYGZhy{}v\PYGZdl{}NODE\PYGZus{}VERSION\PYGZhy{}linux\PYGZhy{}x64.tar.xz}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{C} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{strip}\PYG{o}{\PYGZhy{}}\PYG{n}{components}\PYG{o}{=}\PYG{l+m+mi}{1} \PYGZbs{}
  \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rm} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{node\PYGZhy{}v\PYGZdl{}NODE\PYGZus{}VERSION\PYGZhy{}linux\PYGZhy{}x64.tar.xz}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{SHASUMS256}\PYG{o}{.}\PYG{n}{txt}\PYG{o}{.}\PYG{n}{asc} \PYG{n}{SHASUMS256}\PYG{o}{.}\PYG{n}{txt} \PYGZbs{}
  \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{ln} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{node} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{nodejs}
\end{sphinxVerbatim}

这样，在后续版本需要变更时，只需更改\sphinxcode{\sphinxupquote{NODE\_VERSION}}环境变量即可。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。

\item {} 
ARG

\sphinxcode{\sphinxupquote{ARG}}用来指定构建参数。格式为:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ARG \textless{}参数名\textgreater{}{[}=\textless{}默认值\textgreater{}{]}}}

\end{itemize}

构建参数和 \sphinxcode{\sphinxupquote{ENV}} 的效果一样，都是设置环境变量。所不同的是，\sphinxcode{\sphinxupquote{ARG}} 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 \sphinxcode{\sphinxupquote{ARG}} 保存密码之类的信息，因为 \sphinxcode{\sphinxupquote{docker history}} 还是可以看到所有值的。

\sphinxcode{\sphinxupquote{Dockerfile}} 中的 \sphinxcode{\sphinxupquote{ARG}} 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 \sphinxcode{\sphinxupquote{docker build}} 中用 \sphinxcode{\sphinxupquote{-{-}build-arg \textless{}参数名\textgreater{}=\textless{}值\textgreater{}}} 来覆盖。

\item {} 
VOLUME

\sphinxcode{\sphinxupquote{VOLUME}}用来定义匿名卷，格式为:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{VOLUME {[}"\textless{}路径1\textgreater{}", "\textless{}路径2\textgreater{}"...{]}}}

\item {} 
\sphinxcode{\sphinxupquote{VOLUME \textless{}路径\textgreater{}}}

\end{itemize}

按照最佳实践，在容器运行时，应尽量保持容器存储层不发生写操作，对需要保存的数据，应该保存在卷(\sphinxcode{\sphinxupquote{volume}})中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{VOLUME} \PYG{o}{/}\PYG{n}{data}
\end{sphinxVerbatim}

这里的 \sphinxcode{\sphinxupquote{/data}} 目录就会在运行时自动挂载为匿名卷，任何向 \sphinxcode{\sphinxupquote{/data}} 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。

匿名卷是指在启动容器时，随容器启动而创建，随着容器消亡而淹没于卷列表中（对于 docker run 匿名卷不会被自动删除。

通过\sphinxcode{\sphinxupquote{sudo docker volume ls}}可查看创建的卷。输出如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DRIVER}              \PYG{n}{VOLUME} \PYG{n}{NAME}
\PYG{n}{local}               \PYG{l+m+mi}{002}\PYG{n}{ca4875224a327f6874010974f00395922a210078ae36a5193fc049dfc5c1b}
\PYG{n}{local}               \PYG{l+m+mf}{020e077156}\PYG{n}{ea401e510542c85fdd196c23cbaff97df3a26b0ead23ba7c49d85a}
\PYG{n}{local}               \PYG{n}{service\PYGZus{}mariadb\PYGZus{}data}
\PYG{n}{local}               \PYG{n}{service\PYGZus{}testlink\PYGZus{}data}
\end{sphinxVerbatim}

像\sphinxcode{\sphinxupquote{002ca4875224a327f6874010974f00395922a210078ae36a5193fc049dfc5c1b}}即是匿名卷，通过\sphinxcode{\sphinxupquote{sudo docker inspect 002ca4875224a327f6874010974f00395922a210078ae36a5193fc049dfc5c1b}}查看详情，如下“

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}
    \PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Driver}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{local}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Labels}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{null}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mountpoint}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/var/lib/docker/volumes/002ca4875224a327f6874010974f00395922a210078ae36a5193fc049dfc5c1b/\PYGZus{}data}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{002ca4875224a327f6874010974f00395922a210078ae36a5193fc049dfc5c1b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Options}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{local}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{]}
\end{sphinxVerbatim}

当然，运行时可以覆盖这个挂载设置，如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{run} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{n}{mydata}\PYG{p}{:}\PYG{o}{/}\PYG{n}{data} \PYG{n}{xxxx}
\end{sphinxVerbatim}

在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。
上述查询卷列表中的\sphinxcode{\sphinxupquote{service\_mariadb\_data}}既是此类。

\item {} 
EXPOSE

\sphinxcode{\sphinxupquote{EXPOSE}}用来声明端口，格式为:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{EXPOSE \textless{}端口1\textgreater{} {[}\textless{}端口2\textgreater{}...{]}}}

\end{itemize}

\sphinxcode{\sphinxupquote{EXPOSE}} 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 \sphinxcode{\sphinxupquote{Dockerfile}} 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 \sphinxcode{\sphinxupquote{docker run -P}} 时，会自动随机映射 \sphinxcode{\sphinxupquote{EXPOSE}} 的端口。

要将 \sphinxcode{\sphinxupquote{EXPOSE}} 和在运行时使用 \sphinxcode{\sphinxupquote{-p \textless{}宿主端口\textgreater{}:\textless{}容器端口\textgreater{}}} 区分开来。\sphinxcode{\sphinxupquote{-p}}，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 \sphinxcode{\sphinxupquote{EXPOSE}} 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。

\item {} 
WORKDIR

\sphinxcode{\sphinxupquote{WORKDIR}}用来指定工作目录，格式为:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{WORKDIR \textless{}工作目录路径\textgreater{}}}

\end{itemize}

使用 \sphinxcode{\sphinxupquote{WORKDIR}} 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，\sphinxcode{\sphinxupquote{WORKDIR}} 会帮你建立目录。

有些常犯的错误是把 \sphinxcode{\sphinxupquote{Dockerfile}} 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RUN} \PYG{n}{cd} \PYG{o}{/}\PYG{n}{app}
\PYG{n}{RUN} \PYG{n}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hello}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZgt{}} \PYG{n}{world}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}

如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 \sphinxcode{\sphinxupquote{/app/world.txt}} 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。

之前说过每一个 \sphinxcode{\sphinxupquote{RUN}} 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 \sphinxcode{\sphinxupquote{RUN cd /app}} 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。

因此如果需要改变以后各层的工作目录的位置，那么应该使用 \sphinxcode{\sphinxupquote{WORKDIR}} 指令。

\item {} 
USER

\sphinxcode{\sphinxupquote{USER}}用来指定当前用户，格式为:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{USER \textless{}用户名\textgreater{}{[}:\textless{}用户组\textgreater{}{]}}}

\end{itemize}

\sphinxcode{\sphinxupquote{USER}} 指令和 \sphinxcode{\sphinxupquote{WORKDIR}} 相似，都是改变环境状态并影响以后的层。\sphinxcode{\sphinxupquote{WORKDIR}} 是改变工作目录，\sphinxcode{\sphinxupquote{USER}} 则是改变之后层的执行 \sphinxcode{\sphinxupquote{RUN}}, \sphinxcode{\sphinxupquote{CMD}} 以及\sphinxcode{\sphinxupquote{ENTRYPOINT}} 这类命令的身份。

当然，\sphinxcode{\sphinxupquote{USER}} 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RUN} \PYG{n}{groupadd} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{redis} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{useradd} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{o}{\PYGZhy{}}\PYG{n}{g} \PYG{n}{redis} \PYG{n}{redis}
\PYG{n}{USER} \PYG{n}{redis}
\PYG{n}{RUN} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{redis\PYGZhy{}server}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}
\end{sphinxVerbatim}

如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 \sphinxhref{https://github.com/tianon/gosu}{gosu}。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 建立 redis 用户，并使用 gosu 换另一个用户执行命令}
\PYG{n}{RUN} \PYG{n}{groupadd} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{n}{redis} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{useradd} \PYG{o}{\PYGZhy{}}\PYG{n}{r} \PYG{o}{\PYGZhy{}}\PYG{n}{g} \PYG{n}{redis} \PYG{n}{redis}
\PYG{c+c1}{\PYGZsh{} 下载 gosu}
\PYG{n}{RUN} \PYG{n}{wget} \PYG{o}{\PYGZhy{}}\PYG{n}{O} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{gosu} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{https://github.com/tianon/gosu/releases/download/1.7/gosu\PYGZhy{}amd64}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
    \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{chmod} \PYG{o}{+}\PYG{n}{x} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{gosu} \PYGZbs{}
    \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{gosu} \PYG{n}{nobody} \PYG{n}{true}
\PYG{c+c1}{\PYGZsh{} 设置 CMD，并以另外的用户执行}
\PYG{n}{CMD} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{exec}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gosu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{redis}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{redis\PYGZhy{}server}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}
\end{sphinxVerbatim}

\item {} 
HEALTHCHECK

\sphinxcode{\sphinxupquote{HEALTHCHECK}}用来提供容器内应用进程健康状态检测。
Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了

格式为:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{HEALTHCHECK {[}选项{]} CMD \textless{}命令\textgreater{}}}：设置检查容器健康状况的命令
*\sphinxcode{\sphinxupquote{HEALTHCHECK NONE}}：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令

\end{itemize}

\sphinxcode{\sphinxupquote{HEALTHCHECK}}支持下列选项:
\begin{itemize}
\item {} 
\textendash{}interval=\textless{}间隔\textgreater{}：两次健康检查的间隔，默认为 30 秒；

\item {} 
\textendash{}timeout=\textless{}时长\textgreater{}：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；

\item {} 
\textendash{}retries=\textless{}次数\textgreater{}：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。

\end{itemize}

和 \sphinxcode{\sphinxupquote{CMD}}, \sphinxcode{\sphinxupquote{ENTRYPOINT}} 一样，\sphinxcode{\sphinxupquote{HEALTHCHECK}} 只可以出现一次，如果写了多个，只有最后一个生效。

在 \sphinxcode{\sphinxupquote{HEALTHCHECK {[}选项{]} CMD}} 后面的命令，格式和 \sphinxcode{\sphinxupquote{ENTRYPOINT}} 一样，分为 \sphinxcode{\sphinxupquote{shell}} 格式，和 \sphinxcode{\sphinxupquote{exec}} 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FROM} \PYG{n}{nginx}
\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{update} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{curl} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rm} \PYG{o}{\PYGZhy{}}\PYG{n}{rf} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{apt}\PYG{o}{/}\PYG{n}{lists}\PYG{o}{/}\PYG{o}{*}
\PYG{n}{HEALTHCHECK} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{interval}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{n}{s} \PYGZbs{}
  \PYG{n}{CMD} \PYG{n}{curl} \PYG{o}{\PYGZhy{}}\PYG{n}{fs} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{localhost}\PYG{o}{/} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{exit} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{构建镜像}
\label{\detokenize{docker/practice:id9}}
下面以\sphinxcode{\sphinxupquote{fp-frontend}}为例，介绍如何编写\sphinxcode{\sphinxupquote{Dockerfile}}，构建镜像。
\begin{itemize}
\item {} 
编译打包

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 工程跟目录}
\PYG{n}{cd} \PYG{n}{fp}\PYG{o}{\PYGZhy{}}\PYG{n}{frontend}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 编译}
\PYG{n}{mvn} \PYG{n}{clean} \PYG{n}{package} \PYG{o}{\PYGZhy{}}\PYG{n}{Dmaven}\PYG{o}{.}\PYG{n}{test}\PYG{o}{.}\PYG{n}{skip}\PYG{o}{=}\PYG{n}{true}
\end{sphinxVerbatim}

编译完成后，在\sphinxcode{\sphinxupquote{target/fp-frontend-0.0.1-SNAPSHOT.jar}}即是所需的运行包。
\begin{itemize}
\item {} 
在工程根目录下创建\sphinxcode{\sphinxupquote{Dockerfile}}文件

\end{itemize}

如果按上述步骤操作，可清空\sphinxcode{\sphinxupquote{Dockerfile}}文件，或者删除重建。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 工程根目录}
\PYG{n}{cd} \PYG{n}{fp}\PYG{o}{\PYGZhy{}}\PYG{n}{frontend}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 创建Dockerfile文件}
\PYG{n}{touch} \PYG{n}{Dockerfile}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
增加基础镜像

\end{itemize}

由于是\sphinxcode{\sphinxupquote{java}}工程，引入的基础镜像是\sphinxcode{\sphinxupquote{openjdk:8-jre}}(基础镜像要尽量收拢，稳定，以及尽量小。这里选用jre，而非jdk)。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 编辑Dockerfile}
\PYG{n}{vi} \PYG{n}{Dockerfile}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 增加基础镜像}
\PYG{n}{FROM} \PYG{n}{openjdk}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{o}{\PYGZhy{}}\PYG{n}{jre}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
创建用户

\end{itemize}

按照\sphinxhref{https://confluence.yitu-inc.com/pages/viewpage.action?pageId=307495610}{容器化规范}要求，需要在Dockerfile中定义非root用户，以该用户运行应用，uid要在5000-5100范围内。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}\PYGZsh{} 用户UID
ARG UID=5000

\PYGZsh{}\PYGZsh{} 创建用户组
RUN groupadd \PYGZhy{}r fp

\PYGZsh{}\PYGZsh{} 创建用户
RUN useradd \PYGZhy{}r \PYGZhy{}u \PYGZdl{}UID \PYGZhy{}g fp fp

\PYGZsh{}\PYGZsh{} 使用gosu来切换用户，参考上述USER指令中的介绍
RUN wget \PYGZhy{}O /usr/local/bin/gosu \PYGZdq{}https://github.com/tianon/gosu/releases/download/1.10/gosu\PYGZhy{}amd64\PYGZdq{}
RUN chmod +x /usr/local/bin/gosu \PYGZam{}\PYGZam{} gosu nobody true
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
创建挂载卷

\end{itemize}

在示例应用中，会将日志输出到文件中，日志目录是通过\sphinxcode{\sphinxupquote{LOG\_HOME}}环境变量设置的，具体参考源码中的\sphinxhref{http://gitlab.yitu-inc.com/devops/observability/fp-frontend/blob/master/src/main/resources/logback.xml}{logback.xml}。

所以，这里会用到两个指令\textendash{}ENV和VOLUME:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 设置环境变量}
\PYG{n}{ENV} \PYG{n}{LOG\PYGZus{}HOME}\PYG{o}{=}\PYG{o}{/}\PYG{n}{logs}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 创建日志目录}
\PYG{n}{RUN} \PYG{n}{mkdir} \PYG{o}{/}\PYG{n}{logs}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 容器中默认的执行用户是root，而应用是用非root用户(即之前创建的fp用户)运行的，这里需要切换/logs目录属主}
\PYG{n}{RUN} \PYG{n}{chown} \PYG{n}{fp}\PYG{p}{:}\PYG{n}{fp} \PYG{o}{/}\PYG{n}{logs}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 创建匿名卷，注意: VOLUME指令一定是要在最后，具体参考: VOLUME机制}
\PYG{n}{VOLUME} \PYG{o}{/}\PYG{n}{logs}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
配置运行程序

\end{itemize}

规划应用的运行目录为\sphinxcode{\sphinxupquote{/app}}，应用程序是之前编译输出的\sphinxcode{\sphinxupquote{target/fp-frontend-0.0.1-SNAPSHOT.jar}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 设置工作目录，目录不存在，WORKDIR会自动创建}
\PYG{n}{WORKDIR} \PYG{o}{/}\PYG{n}{app}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 将应用程序从主机上拷贝至容器的/app目录下}
\PYG{n}{COPY} \PYG{n}{target}\PYG{o}{/}\PYG{n}{fp}\PYG{o}{\PYGZhy{}}\PYG{n}{frontend}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{SNAPSHOT}\PYG{o}{.}\PYG{n}{jar} \PYG{o}{/}\PYG{n}{app}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
暴露端口

\end{itemize}

应用对外提供HTTP服务，暴露8081端口，具体参考源码中的\sphinxhref{http://gitlab.yitu-inc.com/devops/observability/fp-frontend/blob/master/src/main/resources/application-dev.yml}{application-dev.yml}。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 暴露端口}
\PYG{n}{EXPOSE} \PYG{l+m+mi}{8081}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
设置应用启动命令

\end{itemize}

由于是\sphinxcode{\sphinxupquote{spring boot}}应用，编译输出的是\sphinxcode{\sphinxupquote{fat jar}}，直接运行jar包即可运行。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 设置启动命令}
\PYG{n}{ENTRYPOINT} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gosu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fp}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{java}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}jar}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fp\PYGZhy{}frontend\PYGZhy{}0.0.1\PYGZhy{}SNAPSHOT.jar}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
优化

按照我们之前的介绍，需要把Dockerfile做个优化:
\begin{itemize}
\item {} 
把版本信息以环境变量(ENV)或者ARG(变量)的形式定义

\item {} 
将RUN指令合并(注意执行顺序)

\end{itemize}

保存Dockerfile。
优化后的Dockerfile参考\sphinxhref{http://gitlab.yitu-inc.com/devops/observability/fp-frontend/tree/docker-0.1/}{docker-0.1}分支。

\item {} 
构建

\end{itemize}

构建镜像，镜像名称为\sphinxcode{\sphinxupquote{fp/frontend}}，tag为\sphinxcode{\sphinxupquote{0.0.1}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 在工程根目录下执行}
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{fp}\PYG{o}{/}\PYG{n}{frontend}\PYG{p}{:}\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{.}
\end{sphinxVerbatim}

构建完成后，执行\sphinxcode{\sphinxupquote{sudo docker images}}查看镜像。
\begin{quote}

注意: 构建过程中需要下载gosu，保证能够连接外网，如果下载失败，重试。
\end{quote}
\begin{itemize}
\item {} 
验证

\end{itemize}

构建完成镜像后，启动容器验证下。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 运行容器}
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{run} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{n}{fp}\PYG{o}{/}\PYG{n}{frontend}\PYG{p}{:}\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

查看容器状态: \sphinxcode{\sphinxupquote{sudo docker ps -a}}，输出如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CONTAINER} \PYG{n}{ID}        \PYG{n}{IMAGE}               \PYG{n}{COMMAND}                  \PYG{n}{CREATED}             \PYG{n}{STATUS}              \PYG{n}{PORTS}                               \PYG{n}{NAMES}
\PYG{n}{ff0474afd136}        \PYG{n}{fp}\PYG{o}{/}\PYG{n}{frontend}\PYG{p}{:}\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mi}{1}   \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gosu fp java \PYGZhy{}jar...}\PYG{l+s+s2}{\PYGZdq{}}   \PYG{l+m+mi}{53} \PYG{n}{seconds} \PYG{n}{ago}      \PYG{n}{Up} \PYG{l+m+mi}{52} \PYG{n}{seconds}       \PYG{l+m+mi}{8081}\PYG{o}{/}\PYG{n}{tcp}                            \PYG{n}{sad\PYGZus{}volhard}
\end{sphinxVerbatim}

容器状态应为\sphinxcode{\sphinxupquote{Up}}。

查看容器日志:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{logs} \PYG{n}{ff0474afd136}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
VOLUME机制

\end{itemize}

在编写Dockerfile时，提到应用会将日志输出到文件，所以创建了挂载卷(/logs)。上述运行容器时，并没有通过\sphinxcode{\sphinxupquote{-v}}指定挂载卷。这时，docker会默认创建个挂载卷，这就是所谓的\sphinxcode{\sphinxupquote{匿名卷}}。

执行\sphinxcode{\sphinxupquote{sudo docker inspect ff0474afd136 \textbar{} grep -A 10 Mounts}}查看挂载卷信息，如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mounts}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}
            \PYG{p}{\PYGZob{}}
                \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{volume}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{6b00a9e75314367e71c63e408b1bb27c6bf9cc2ec537153e452104671a47a36c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Source}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/var/lib/docker/volumes/6b00a9e75314367e71c63e408b1bb27c6bf9cc2ec537153e452104671a47a36c/\PYGZus{}data}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Destination}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/logs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Driver}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{local}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mode}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RW}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{true}\PYG{p}{,}
                \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Propagation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
            \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

可以看到主机上的挂载卷是在\sphinxcode{\sphinxupquote{/var/lib/docker/volumes/6b00a9e75314367e71c63e408b1bb27c6bf9cc2ec537153e452104671a47a36c/\_data}}目录下，查看该目录，应有\sphinxcode{\sphinxupquote{debug-log.log}}文件(注意，需使用root用户)。

前面提到，可以使用\sphinxcode{\sphinxupquote{-v}}命令指定主机挂载卷，如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo docker run \PYGZhy{}d \PYGZhy{}v \PYGZdl{}PWD/logs:/logs fp/frontend:0.0.1
\end{sphinxVerbatim}

这里是将当前目录下的\sphinxcode{\sphinxupquote{logs}}目录作为挂载卷。这时，会有两种情况:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
* 如果本地logs目录不存在，则docker会自动创建，目录的权限为运行docker的用户(示例中为root)
* 如果本地logs目录存在，则docker以本地目录创建挂载卷。
\end{sphinxVerbatim}

下面说下第二种情况。在本地logs目录存在的情况下，docker的原则是不能删除本地文件，所以，会以本地文件的信息创建挂载卷(包括目录的属主，权限，目录下的内容)。
通过\sphinxcode{\sphinxupquote{-v}}命令， 就会使用定义的命名卷(\sphinxcode{\sphinxupquote{\$PWD/logs}})挂载到容器\sphinxcode{\sphinxupquote{/logs}}目录，替代Dockerfile中定义的匿名卷的挂载位置。也就是说，在容器中操作/logs目录，就等同于操作主机上的\sphinxcode{\sphinxupquote{\$PWD/logs}}目录。

这里就可能会存在一个问题，由于容器中是以\sphinxcode{\sphinxupquote{fp}}用户运行的，而本地的\sphinxcode{\sphinxupquote{\$PWD/logs}}目录的属主可能与容器中的\sphinxcode{\sphinxupquote{fp}}不一致(其实是uid不一致)。启动时就会报错，如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{04}\PYG{p}{:}\PYG{l+m+mi}{04}\PYG{p}{:}\PYG{l+m+mi}{06}\PYG{p}{,}\PYG{l+m+mi}{681} \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{n}{ERROR} \PYG{o+ow}{in} \PYG{n}{ch}\PYG{o}{.}\PYG{n}{qos}\PYG{o}{.}\PYG{n}{logback}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{rolling}\PYG{o}{.}\PYG{n}{RollingFileAppender}\PYG{p}{[}\PYG{n}{FILE}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{openFile}\PYG{p}{(}\PYG{o}{/}\PYG{n}{logs}\PYG{o}{/}\PYG{n}{debug}\PYG{o}{\PYGZhy{}}\PYG{n}{log}\PYG{o}{.}\PYG{n}{log}\PYG{p}{,}\PYG{n}{true}\PYG{p}{)} \PYG{n}{call} \PYG{n}{failed}\PYG{o}{.} \PYG{n}{java}\PYG{o}{.}\PYG{n}{io}\PYG{o}{.}\PYG{n}{FileNotFoundException}\PYG{p}{:} \PYG{o}{/}\PYG{n}{logs}\PYG{o}{/}\PYG{n}{debug}\PYG{o}{\PYGZhy{}}\PYG{n}{log}\PYG{o}{.}\PYG{n}{log} \PYG{p}{(}\PYG{n}{Permission} \PYG{n}{denied}\PYG{p}{)}
	\PYG{n}{at} \PYG{n}{java}\PYG{o}{.}\PYG{n}{io}\PYG{o}{.}\PYG{n}{FileNotFoundException}\PYG{p}{:} \PYG{o}{/}\PYG{n}{logs}\PYG{o}{/}\PYG{n}{debug}\PYG{o}{\PYGZhy{}}\PYG{n}{log}\PYG{o}{.}\PYG{n}{log} \PYG{p}{(}\PYG{n}{Permission} \PYG{n}{denied}\PYG{p}{)}
	\PYG{n}{at} 	\PYG{n}{at} \PYG{n}{java}\PYG{o}{.}\PYG{n}{io}\PYG{o}{.}\PYG{n}{FileOutputStream}\PYG{o}{.}\PYG{n}{open0}\PYG{p}{(}\PYG{n}{Native} \PYG{n}{Method}\PYG{p}{)}
	\PYG{n}{at} 	\PYG{n}{at} \PYG{n}{java}\PYG{o}{.}\PYG{n}{io}\PYG{o}{.}\PYG{n}{FileOutputStream}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{FileOutputStream}\PYG{o}{.}\PYG{n}{java}\PYG{p}{:}\PYG{l+m+mi}{270}\PYG{p}{)}
	\PYG{n}{at} 	\PYG{n}{at} \PYG{n}{java}\PYG{o}{.}\PYG{n}{io}\PYG{o}{.}\PYG{n}{FileOutputStream}\PYG{o}{.}\PYG{o}{\PYGZlt{}}\PYG{n}{init}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{FileOutputStream}\PYG{o}{.}\PYG{n}{java}\PYG{p}{:}\PYG{l+m+mi}{213}\PYG{p}{)}
	\PYG{n}{at} 	\PYG{n}{at} \PYG{n}{ch}\PYG{o}{.}\PYG{n}{qos}\PYG{o}{.}\PYG{n}{logback}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{recovery}\PYG{o}{.}\PYG{n}{ResilientFileOutputStream}\PYG{o}{.}\PYG{o}{\PYGZlt{}}\PYG{n}{init}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{ResilientFileOutputStream}\PYG{o}{.}\PYG{n}{java}\PYG{p}{:}\PYG{l+m+mi}{26}\PYG{p}{)}
\end{sphinxVerbatim}

注: 可以将Dockerfile中的\sphinxcode{\sphinxupquote{ENTRYPOINT}}改成\sphinxcode{\sphinxupquote{CMD}}，然后重新构建镜像，以交互的方式进入容器\sphinxcode{\sphinxupquote{sudo docker run -ti -v \$PWD/logs:/logs fp/frontend:0.0.1 bash}}，查看\sphinxcode{\sphinxupquote{/logs}}的属主信息。
\begin{itemize}
\item {} 
如何解决？

\end{itemize}

除了上述VOLUME的问题外，还有个问题。

在Dockerfile中指定启动命令中\sphinxcode{\sphinxupquote{ENTRYPOINT {[}"gosu", "fp", "java", "-jar", "fp-frontend-0.0.1-SNAPSHOT.jar"{]}}}，并没有使用\sphinxcode{\sphinxupquote{APP\_VERSION}}环境变量。这时因为，这里是把\sphinxcode{\sphinxupquote{ENTRYPOINT}}当做字符串解析的，无法使用环境变量。
基于此，可以将启动命令以脚本的形式体现。在启动脚本中，设置挂载卷的属主权限；并可以使用环境变量。

在工程根目录下增加\sphinxcode{\sphinxupquote{start.sh}}脚本:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}!/bin/bash
chown fp:fp /logs
exec gosu fp java \PYGZhy{}jar fp\PYGZhy{}frontend\PYGZhy{}\PYGZdl{}APP\PYGZus{}VERSION.jar
\end{sphinxVerbatim}

给脚本赋权限(\sphinxcode{\sphinxupquote{chmod +x start.sh}})

修改Dockerfile:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 将启动脚本拷贝至容器，/usr/local/bin默认在PATH路径下}
\PYG{n}{COPY} \PYG{n}{start}\PYG{o}{.}\PYG{n}{sh} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n+nb}{bin}\PYG{o}{/}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 需改ENTRYPOINT}
\PYG{n}{ENTRYPOINT} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{start.sh}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

参考源码\sphinxhref{http://gitlab.yitu-inc.com/devops/observability/fp-frontend/tree/docker-0.2}{docker-0.2}分支。

构建镜像，按照挂载卷的方式启动容器，验证。


\subsection{镜像管理}
\label{\detokenize{docker/practice:id10}}
在本地通过\sphinxcode{\sphinxupquote{sudo docker build}}命令构建镜像，只存在本地镜像仓库，不方便共享部署。该章节介绍如何使用镜像仓库来管理和共享镜像。

这里使用的是公司的\sphinxhref{https://harbor.yitu-inc.com/harbor/projects}{harbor}。
\begin{itemize}
\item {} 
首先，使用域账号登录harbor: https://harbor.yitu-inc.com/harbor/projects，创建个人项目，例如 \sphinxcode{\sphinxupquote{docker-in-action}}。
\begin{quote}

注意: 此处是验证用途，将项目设置为私有。
\end{quote}

如果要共享镜像，需要将镜像推送(\sphinxcode{\sphinxupquote{push}})到仓库中。

\item {} 
接着，需要在本地登录镜像仓库:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{} 登录镜像仓库，输入域账号用户名和密码}
\PYG{o}{\PYGZgt{}} \PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{login} \PYG{n}{harbor}\PYG{o}{.}\PYG{n}{yitu}\PYG{o}{\PYGZhy{}}\PYG{n}{inc}\PYG{o}{.}\PYG{n}{com}
\PYG{n}{Username} \PYG{p}{(}\PYG{n}{loulou}\PYG{o}{.}\PYG{n}{liu}\PYG{p}{)}\PYG{p}{:} 
\PYG{n}{Password}\PYG{p}{:} 
\PYG{n}{Login} \PYG{n}{Succeeded}
\end{sphinxVerbatim}

\item {} 
修改镜像名称

镜像要推送到仓库，镜像名称中必须带上仓库的地址信息。格式为 \sphinxcode{\sphinxupquote{\textless{}repo\_url\textgreater{}/\textless{}project\_name\textgreater{}/\textless{}image\_name\textgreater{}:\textless{}image\_tag\textgreater{}}}。

这里要使用到\sphinxcode{\sphinxupquote{sudo docker tag}}命令，格式为: \sphinxcode{\sphinxupquote{sudo docker tag SOURCE\_IMAGE{[}:TAG{]} TARGET\_IMAGE{[}:TAG{]}}}。

按照格式，修改\sphinxcode{\sphinxupquote{fp/frontend:0.0.1}}镜像名称:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{tag} \PYG{n}{fp}\PYG{o}{/}\PYG{n}{frontend}\PYG{p}{:}\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mi}{1} \PYG{n}{harbor}\PYG{o}{.}\PYG{n}{yitu}\PYG{o}{\PYGZhy{}}\PYG{n}{inc}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{docker}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in}\PYG{o}{\PYGZhy{}}\PYG{n}{action}\PYG{o}{/}\PYG{n}{fp}\PYG{o}{/}\PYG{n}{frontend}\PYG{p}{:}\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\item {} 
推送镜像

推送镜像，使用的\sphinxcode{\sphinxupquote{sudo docker push \textless{}image\_name\textgreater{}:\textless{}image\_tag\textgreater{}}}。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{push} \PYG{n}{harbor}\PYG{o}{.}\PYG{n}{yitu}\PYG{o}{\PYGZhy{}}\PYG{n}{inc}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{docker}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in}\PYG{o}{\PYGZhy{}}\PYG{n}{action}\PYG{o}{/}\PYG{n}{fp}\PYG{o}{/}\PYG{n}{frontend}\PYG{p}{:}\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

输出如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{push} \PYG{n}{refers} \PYG{n}{to} \PYG{n}{a} \PYG{n}{repository} \PYG{p}{[}\PYG{n}{harbor}\PYG{o}{.}\PYG{n}{yitu}\PYG{o}{\PYGZhy{}}\PYG{n}{inc}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{docker}\PYG{o}{\PYGZhy{}}\PYG{o+ow}{in}\PYG{o}{\PYGZhy{}}\PYG{n}{action}\PYG{o}{/}\PYG{n}{fp}\PYG{o}{/}\PYG{n}{frontend}\PYG{p}{]}
\PYG{l+m+mi}{174}\PYG{n}{c6af1069e}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{n}{a66ac566a07f}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{l+m+mi}{752}\PYG{n}{b23d46029}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{l+m+mi}{94}\PYG{n}{cf736a7b95}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{l+m+mi}{2}\PYG{n}{d63501da7e5}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{n}{e6ae888dd260}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{l+m+mi}{80917357}\PYG{n}{f055}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{n}{bfc5dbc4d7a7}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{n}{b53b57a50746}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{n}{d2518892581f}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{n}{c581f4ede92d}\PYG{p}{:} \PYG{n}{Pushed} 
\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{n}{digest}\PYG{p}{:} \PYG{n}{sha256}\PYG{p}{:}\PYG{n}{a891febf089db7db1e965ef036aee56bf1053f7a58458397fb575b5088dd7a5f} \PYG{n}{size}\PYG{p}{:} \PYG{l+m+mi}{2624}
\end{sphinxVerbatim}

上传完成后，刷新harbor页面，即可在 镜像仓库 页面看到刚上传的镜像了。

那在其他环境上，就可以通过\sphinxcode{\sphinxupquote{sudo docker pull harbor.yitu-inc.com/docker-in-action/fp/frontend:0.0.1}}的方式拉取镜像了。
\begin{quote}

说明: 此处设置项目的访问界别为 私有 ，拉取镜像需要login。如果设置为 公开，这无需login。
\end{quote}
\begin{quote}

注意: 这里拉取镜像时，镜像名称不再是 fp/frontend，而是带有镜像仓库地址的。实际上，对于不带仓库地址的镜像，在拉取时，是从设置的默认镜像仓库中拉取的。
\end{quote}

\end{itemize}

\sphinxcode{\sphinxupquote{fp/backend}}工程类似，可以参考着制作镜像。具体的可参考源码中的Dockerfile。


\section{部署}
\label{\detokenize{docker/practice:id11}}
模拟服务的请求流向大概如下:

\sphinxincludegraphics{{request-flow}.png}

图4.1 示例应用请求流向

这里需要部署两个应用(\sphinxcode{\sphinxupquote{fp-frontend}}和\sphinxcode{\sphinxupquote{fp-backend}})，以及外部存储服务(\sphinxcode{\sphinxupquote{mysql}})。


\subsection{mysql}
\label{\detokenize{docker/practice:mysql}}
首先，部署mysql服务。这里直接使用docker官网镜像\textendash{}\sphinxcode{\sphinxupquote{mysql:5.7}}。
\begin{itemize}
\item {} 
启动服务

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{run} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{n}{mysql} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{MYSQL\PYGZus{}ROOT\PYGZus{}PASSWORD}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{root\PYGZus{}password}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{\PYGZlt{}}\PYG{n}{mysql\PYGZus{}data\PYGZus{}volume}\PYG{o}{\PYGZgt{}}\PYG{p}{:}\PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{mysql} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{restart}\PYG{o}{=}\PYG{n}{always} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mi}{3306}\PYG{p}{:}\PYG{l+m+mi}{3306} \PYG{n}{mysql}\PYG{p}{:}\PYG{l+m+mf}{5.7} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{character}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{server}\PYG{o}{=}\PYG{n}{utf8mb4} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{collation}\PYG{o}{\PYGZhy{}}\PYG{n}{server}\PYG{o}{=}\PYG{n}{utf8mb4\PYGZus{}unicode\PYGZus{}ci}
\end{sphinxVerbatim}
\begin{quote}

说明:
\begin{itemize}
\item {} 
\textless{}root\_password\textgreater{}: root用户的密码，需要修改。示例应用中使用的是root。

\item {} 
\textless{}mysql\_data\_volume\textgreater{}: 本地挂载卷，持久化mysql数据，需要修改。

\item {} 
需要将mysql作为服务，所以需要将3306端口映射出来，示例应用中使用的是3306，如存在端口占用，可以修改。

\end{itemize}
\end{quote}
\begin{itemize}
\item {} 
建表

\end{itemize}

示例应用中需要访问数据表，参考如下命令初始化数据:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}\PYGZsh{} 在docker容器中，执行建库建表操作
sudo docker exec \PYGZhy{}ti mysql bash

\PYGZsh{}\PYGZsh{} 登录

\PYGZgt{} mysql \PYGZhy{}u root \PYGZhy{}h 127.0.0.1 \PYGZhy{}p
输入密码

\PYGZsh{}\PYGZsh{} 建库，schema为fp
\PYGZgt{} create database fp;

\PYGZsh{}\PYGZsh{} 创建用户，用户名和密码均为fp
\PYGZgt{}  use fp;
\PYGZgt{} create user fp identified by \PYGZsq{}fp\PYGZsq{};
\PYGZgt{} grant all privileges on *.* to fp@\PYGZsq{}\PYGZpc{}\PYGZsq{} identified by \PYGZsq{}fp\PYGZsq{};

\PYGZsh{}\PYGZsh{} 建表，表名为 resource
\PYGZgt{} create table resource (
	id int(11) not null auto\PYGZus{}increment primary key,
    {}`born\PYGZhy{}year{}` smallint(6) not null default 0,
    {}`face\PYGZhy{}image\PYGZhy{}id{}` bigint not null default 0,
    {}`face\PYGZhy{}image\PYGZhy{}uri{}` varchar(64) character set utf8 not null default \PYGZsq{}\PYGZsq{},
    {}`gender{}` tinyint(2) not null default 0,
    {}`name{}` varchar(16) character set utf8 not null default \PYGZsq{}\PYGZsq{},
    {}`person\PYGZhy{}id{}` int(11) not null default 0,
    {}`picture\PYGZhy{}uri{}` varchar(128) character set utf8 not null default \PYGZsq{}\PYGZsq{}
) charset=utf8;

\PYGZsh{}\PYGZsh{} 写入测试数据
\PYGZgt{} insert into resource ({}`born\PYGZhy{}year{}`, {}`face\PYGZhy{}image\PYGZhy{}id{}`, {}`face\PYGZhy{}image\PYGZhy{}uri{}`, {}`gender{}`, {}`name{}`, {}`person\PYGZhy{}id{}`, {}`picture\PYGZhy{}uri{}`) values (\PYGZsq{}76\PYGZsq{}, \PYGZsq{}3288935160016879295\PYGZsq{}, \PYGZsq{}BrScBCcHlmKAfybIQqMu\PYGZsq{}, \PYGZsq{}0\PYGZsq{}, \PYGZsq{}KGPJhDclQ3\PYGZsq{}, \PYGZsq{}120905\PYGZsq{}, \PYGZsq{}xGTcUWP5x7rO7ZewlHDs\PYGZsq{}
);
\end{sphinxVerbatim}

退出容器。


\subsection{fp-backend}
\label{\detokenize{docker/practice:fp-backend}}\begin{quote}

说明: 最终镜像已推送至 harbor，可通过 \sphinxcode{\sphinxupquote{docker pull harbor.yitu-inc.com/observability/fp/backend:0.0.1}}拉取。
\end{quote}

\sphinxcode{\sphinxupquote{fp-backend}}中需要连接\sphinxcode{\sphinxupquote{mysql}}数据库，连接信息是在源码\sphinxhref{http://gitlab.yitu-inc.com/devops/observability/fp-backend/blob/master/src/main/resources/application-dev.yml}{application-dev.yml}。如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
spring:
  datasource:
    driver\PYGZhy{}class\PYGZhy{}name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/fp?useUnicode=true\PYGZam{}characterEncoding=utf\PYGZhy{}8\PYGZam{}useSSL=false
    username: fp
    password: fp
\end{sphinxVerbatim}

而在部署中，需要根据实际的\sphinxcode{\sphinxupquote{mysql}}服务修改配置。

这里有两种方式，一是通过挂载卷的方式，在主机上保存一份\sphinxcode{\sphinxupquote{application-dev.yml}}，通过挂载的方式映射到容器中；一是通过环境变量的方式。这里使用第二种方式。(第一种可以参考日志目录挂载的方式自行验证，需要注意的是，\sphinxcode{\sphinxupquote{-v}}参数中主机上的配置文件路径需要是绝对路径)。

通过环境变量传入参数，需要两部分，一是配置文件中修改为环境变量的方式(\sphinxcode{\sphinxupquote{spring boot}}的方式，其他语言框架类同)；一是在启动容器的时候，传入环境变量。
\begin{itemize}
\item {} 
修改配置文件，如下：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
spring:
  datasource:
    driver\PYGZhy{}class\PYGZhy{}name: com.mysql.jdbc.Driver
    url: jdbc:mysql://\PYGZdl{}\PYGZob{}MYSQL\PYGZus{}HOST\PYGZcb{}:\PYGZdl{}\PYGZob{}MYSQL\PYGZus{}PORT\PYGZcb{}/\PYGZdl{}\PYGZob{}MYSQL\PYGZus{}DATABASE\PYGZcb{}?useUnicode=true\PYGZam{}characterEncoding=utf\PYGZhy{}8\PYGZam{}useSSL=false
    username: \PYGZdl{}\PYGZob{}MYSQL\PYGZus{}USERNAME\PYGZcb{}
    password: \PYGZdl{}\PYGZob{}MYSQL\PYGZus{}PASSWORD\PYGZcb{}
\end{sphinxVerbatim}
\begin{quote}

说明: 定义了 \sphinxcode{\sphinxupquote{MYSQL\_HOST}}，\sphinxcode{\sphinxupquote{MYSQL\_PORT}}，\sphinxcode{\sphinxupquote{MYSQL\_DATABASE}}，\sphinxcode{\sphinxupquote{MYSQL\_USERNAME}}，\sphinxcode{\sphinxupquote{MYSQL\_PASSWORD}} 五个环境变量。
\end{quote}

参考源码\sphinxhref{http://gitlab.yitu-inc.com/devops/observability/fp-backend/tree/docker-0.1}{docker-0.1}分支。
\begin{itemize}
\item {} 
重新构建镜像

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{build} \PYG{o}{\PYGZhy{}}\PYG{n}{t} \PYG{n}{fp}\PYG{o}{/}\PYG{n}{backend}\PYG{p}{:}\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{.}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
运行容器

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{docker} \PYG{n}{run} \PYG{o}{\PYGZhy{}}\PYG{n}{d} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{name} \PYG{n}{fp}\PYG{o}{\PYGZhy{}}\PYG{n}{backend} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{MYSQL\PYGZus{}HOST}\PYG{o}{=}\PYG{l+m+mf}{10.10}\PYG{o}{.}\PYG{l+m+mf}{23.115} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{MYSQL\PYGZus{}PORT}\PYG{o}{=}\PYG{l+m+mi}{3307} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{MYSQL\PYGZus{}DATABASE}\PYG{o}{=}\PYG{n}{fp} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{MYSQL\PYGZus{}USERNAME}\PYG{o}{=}\PYG{n}{fp} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{n}{MYSQL\PYGZus{}PASSWORD}\PYG{o}{=}\PYG{n}{fp} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{l+m+mi}{8082}\PYG{p}{:}\PYG{l+m+mi}{8082} \PYG{n}{fp}\PYG{o}{/}\PYG{n}{backend}\PYG{p}{:}\PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}
\begin{quote}

说明:
\begin{itemize}
\item {} 
按照之前定义的环境变量，通过\sphinxcode{\sphinxupquote{-e}}参数依次传入

\item {} 
\sphinxcode{\sphinxupquote{fp-backend}}对外提供HTTP服务，暴露端口为 \sphinxcode{\sphinxupquote{8082}}，需要通过\sphinxcode{\sphinxupquote{-p}}参数映射到主机。

\end{itemize}
\end{quote}
\begin{quote}

注意: 在指定\sphinxcode{\sphinxupquote{mysql}}服务的IP时，需要指定主机上的公网IP，不能使用\sphinxcode{\sphinxupquote{localhost}}或者\sphinxcode{\sphinxupquote{127.0.0.1}}。因为是在容器中访问的\sphinxcode{\sphinxupquote{mysql}}，指定\sphinxcode{\sphinxupquote{localhost}}访问的是容器内部网络。(可以通过\textendash{}network=host启动\sphinxcode{\sphinxupquote{mysql}})。
\end{quote}
\begin{itemize}
\item {} 
验证

\end{itemize}

访问 \sphinxcode{\sphinxupquote{http://localhost:8082/fp/backend/track/fetch}}，结果如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}
    \PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{id}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bornYear}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{76}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{faceImageId}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3288935160016879295}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{faceImageUri}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BrScBCcHlmKAfybIQqMu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gender}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{KGPJhDclQ3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{personId}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{120905}\PYG{p}{,}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pictureUri}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xGTcUWP5x7rO7ZewlHDs}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{]}
\end{sphinxVerbatim}


\subsection{fp-frontend}
\label{\detokenize{docker/practice:fp-frontend}}\begin{quote}

说明: 最终镜像已推送至 harbor，可以通过\sphinxcode{\sphinxupquote{docker pull harbor.yitu-inc.com/observability/fp/frontend:0.0.1}}拉取。
\end{quote}

\sphinxcode{\sphinxupquote{fp-frontend}}需要访问\sphinxcode{\sphinxupquote{fp-backend}}的接口，同样，需要定制化配置。参考源码中\sphinxhref{http://gitlab.yitu-inc.com/devops/observability/fp-frontend/blob/docker-0.3/src/main/resources/application-dev.yml}{docker-0.3}分支。

重新构建镜像。
\begin{itemize}
\item {} 
启动容器

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo docker run \PYGZhy{}d \PYGZhy{}\PYGZhy{}name fp\PYGZhy{}frontend \PYGZhy{}e FP\PYGZus{}BACKEND\PYGZus{}HOST=10.10.23.115 \PYGZhy{}v \PYGZdl{}PWD/logs:/logs \PYGZhy{}p 8081:8081 fp/frontend:0.0.3
\end{sphinxVerbatim}
\begin{quote}

说明:
\begin{itemize}
\item {} 
FP\_BACKEND\_HOST: 与mysql类似，这里应该指定公网IP

\item {} 
FP\_BACKEND\_PORT: 配置文件中给出了默认值8082，与实际运行情况一致，这里无需指定了。

\item {} 
\sphinxcode{\sphinxupquote{fp-frontend}}对外暴露\sphinxcode{\sphinxupquote{8081}}端口。

\end{itemize}
\end{quote}
\begin{itemize}
\item {} 
验证

\end{itemize}

访问\sphinxcode{\sphinxupquote{http://localhost:8081/fp/frontend/log/fetch/1}}，结果如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SYeSxTc5UAFlp7lX7j3D}
\end{sphinxVerbatim}

这时，可以通过\sphinxcode{\sphinxupquote{sudo docker logs}}查询\sphinxcode{\sphinxupquote{fp-frontend}}和\sphinxcode{\sphinxupquote{fp-backend}}的日志，查看调用过程。


\chapter{附录}
\label{\detokenize{docker/appendix:id1}}\label{\detokenize{docker/appendix::doc}}

\section{容器化规范}
\label{\detokenize{docker/appendix:id2}}
\sphinxhref{https://confluence.yitu-inc.com/pages/viewpage.action?pageId=307495610}{容器化规范}。


\section{最佳实践(image)}
\label{\detokenize{docker/appendix:image}}

\subsection{一般性的指南和建议}
\label{\detokenize{docker/appendix:id3}}

\subsubsection{容器应该是短暂的}
\label{\detokenize{docker/appendix:id4}}
通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。


\subsubsection{使用 .dockerignore 文件}
\label{\detokenize{docker/appendix:dockerignore}}
使用 Dockerfile 构建镜像时最好是将 Dockerfile 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 .dockerignore 文件来指定要忽略的文件和目录。.dockerignore 文件的排除模式语法和 Git 的 .gitignore 文件相似。


\subsubsection{使用多阶段构建}
\label{\detokenize{docker/appendix:id5}}
在 Docker 17.05 以上版本中，你可以使用 多阶段构建 来减少所构建镜像的大小。


\subsubsection{避免安装不必要的包}
\label{\detokenize{docker/appendix:id6}}
为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。


\subsubsection{一个容器只运行一个进程}
\label{\detokenize{docker/appendix:id7}}
应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。

如果容器互相依赖，你可以使用 Docker 自定义网络 来把这些容器连接起来。


\subsubsection{镜像层数尽可能少}
\label{\detokenize{docker/appendix:id8}}
你需要在 Dockerfile 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。


\subsubsection{将多行参数排序}
\label{\detokenize{docker/appendix:id9}}
将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 PRs 阅读和审查。建议在反斜杠符号 \textbackslash{} 之前添加一个空格，以增加可读性。

下面是来自 buildpack-deps 镜像的例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{update} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYGZbs{}
  \PYG{n}{bzr} \PYGZbs{}
  \PYG{n}{cvs} \PYGZbs{}
  \PYG{n}{git} \PYGZbs{}
  \PYG{n}{mercurial} \PYGZbs{}
  \PYG{n}{subversion}
\end{sphinxVerbatim}


\subsubsection{构建缓存}
\label{\detokenize{docker/appendix:id10}}
在镜像的构建过程中，Docker 会遍历 Dockerfile 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用 \textendash{}no-cache=true 选项。

但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：

从一个基础镜像开始（FROM 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。
在大多数情况下，只需要简单地对比 Dockerfile 中的指令和子镜像。然而，有些指令需要更多的检查和解释。
对于 ADD 和 COPY 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。
除了 ADD 和 COPY 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 RUN apt-get -y update 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。
一旦缓存失效，所有后续的 Dockerfile 指令都将产生新的镜像，缓存不会被使用。


\subsection{Dockerfile 指令}
\label{\detokenize{docker/appendix:dockerfile}}
下面针对 Dockerfile 中各种指令的最佳编写方式给出建议。


\subsubsection{FROM}
\label{\detokenize{docker/appendix:from}}
尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 Alpine 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。


\subsubsection{LABEL}
\label{\detokenize{docker/appendix:label}}
你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 LABEL 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。\# 开头的行是注释内容。

注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Set one or more individual labels}
\PYG{n}{LABEL} \PYG{n}{com}\PYG{o}{.}\PYG{n}{example}\PYG{o}{.}\PYG{n}{version}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.0.1\PYGZhy{}beta}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{LABEL} \PYG{n}{vendor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ACME Incorporated}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{LABEL} \PYG{n}{com}\PYG{o}{.}\PYG{n}{example}\PYG{o}{.}\PYG{n}{release}\PYG{o}{\PYGZhy{}}\PYG{n}{date}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2015\PYGZhy{}02\PYGZhy{}12}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{LABEL} \PYG{n}{com}\PYG{o}{.}\PYG{n}{example}\PYG{o}{.}\PYG{n}{version}\PYG{o}{.}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{production}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

一个镜像可以包含多个标签，但建议将多个标签放入到一个 LABEL 指令中。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Set multiple labels at once, using line\PYGZhy{}continuation characters to break long lines}
\PYG{n}{LABEL} \PYG{n}{vendor}\PYG{o}{=}\PYG{n}{ACME}\PYGZbs{} \PYG{n}{Incorporated} \PYGZbs{}
      \PYG{n}{com}\PYG{o}{.}\PYG{n}{example}\PYG{o}{.}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{beta}\PYG{o}{=} \PYGZbs{}
      \PYG{n}{com}\PYG{o}{.}\PYG{n}{example}\PYG{o}{.}\PYG{o+ow}{is}\PYG{o}{\PYGZhy{}}\PYG{n}{production}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
      \PYG{n}{com}\PYG{o}{.}\PYG{n}{example}\PYG{o}{.}\PYG{n}{version}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.0.1\PYGZhy{}beta}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
      \PYG{n}{com}\PYG{o}{.}\PYG{n}{example}\PYG{o}{.}\PYG{n}{release}\PYG{o}{\PYGZhy{}}\PYG{n}{date}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2015\PYGZhy{}02\PYGZhy{}12}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

关于标签可以接受的键值对，参考 \sphinxhref{https://docs.docker.com/config/labels-custom-metadata/}{Understanding object labels}。关于查询标签信息，参考 \sphinxhref{https://docs.docker.com/config/labels-custom-metadata/}{Managing labels on objects}。


\subsubsection{RUN}
\label{\detokenize{docker/appendix:run}}
为了保持 \sphinxcode{\sphinxupquote{Dockerfile}} 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 \sphinxcode{\sphinxupquote{RUN}} 指令用反斜杠\sphinxcode{\sphinxupquote{\textbackslash{}}} 分割成多行。


\subsubsection{apt-get}
\label{\detokenize{docker/appendix:apt-get}}
\sphinxcode{\sphinxupquote{RUN}} 指令最常见的用法是安装包用的 \sphinxcode{\sphinxupquote{apt-get}}。因为 \sphinxcode{\sphinxupquote{RUN apt-get}} 指令会安装包，所以有几个问题需要注意。

不要使用 \sphinxcode{\sphinxupquote{RUN apt-get upgrade}} 或 \sphinxcode{\sphinxupquote{dist-upgrade}}，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 \sphinxcode{\sphinxupquote{foo}}，需要升级，使用 \sphinxcode{\sphinxupquote{apt-get install -y foo}} 就行，该指令会自动升级 \sphinxcode{\sphinxupquote{foo}} 包。

永远将 \sphinxcode{\sphinxupquote{RUN apt-get update}} 和 \sphinxcode{\sphinxupquote{apt-get install}} 组合成一条 \sphinxcode{\sphinxupquote{RUN}} 声明，例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{update} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYGZbs{}
        \PYG{n}{package}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYGZbs{}
        \PYG{n}{package}\PYG{o}{\PYGZhy{}}\PYG{n}{baz} \PYGZbs{}
        \PYG{n}{package}\PYG{o}{\PYGZhy{}}\PYG{n}{foo}
\end{sphinxVerbatim}

将 \sphinxcode{\sphinxupquote{apt-get update}} 放在一条单独的 RUN 声明中会导致缓存问题以及后续的 \sphinxcode{\sphinxupquote{apt-get install}} 失败。比如，假设你有一个 Dockerfile 文件：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FROM} \PYG{n}{ubuntu}\PYG{p}{:}\PYG{l+m+mf}{18.04}

\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{update}

\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{curl}
\end{sphinxVerbatim}

构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 \sphinxcode{\sphinxupquote{apt-get install}} 添加了一个包：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FROM} \PYG{n}{ubuntu}\PYG{p}{:}\PYG{l+m+mf}{18.04}

\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{update}

\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{curl} \PYG{n}{nginx}
\end{sphinxVerbatim}

Docker 发现修改后的 \sphinxcode{\sphinxupquote{RUN apt-get update}} 指令和之前的完全一样。所以，\sphinxcode{\sphinxupquote{apt-get update}} 不会执行，而是使用之前的缓存镜像。因为 \sphinxcode{\sphinxupquote{apt-get update}} 没有运行，后面的 \sphinxcode{\sphinxupquote{apt-get install}} 可能安装的是过时的 \sphinxcode{\sphinxupquote{curl}} 和 \sphinxcode{\sphinxupquote{nginx}} 版本。

使用 \sphinxcode{\sphinxupquote{RUN apt-get update \&\& apt-get install -y}} 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 \sphinxcode{\sphinxupquote{cache busting}}。你也可以显示指定一个包的版本号来达到 \sphinxcode{\sphinxupquote{cache-busting}}，这就是所谓的固定版本，例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{update} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYGZbs{}
    \PYG{n}{package}\PYG{o}{\PYGZhy{}}\PYG{n}{bar} \PYGZbs{}
    \PYG{n}{package}\PYG{o}{\PYGZhy{}}\PYG{n}{baz} \PYGZbs{}
    \PYG{n}{package}\PYG{o}{\PYGZhy{}}\PYG{n}{foo}\PYG{o}{=}\PYG{l+m+mf}{1.3}\PYG{o}{.}\PYG{o}{*}
\end{sphinxVerbatim}

固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。

下面是一个 RUN 指令的示例模板，展示了所有关于 apt-get 的建议。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{update} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYGZbs{}
    \PYG{n}{aufs}\PYG{o}{\PYGZhy{}}\PYG{n}{tools} \PYGZbs{}
    \PYG{n}{automake} \PYGZbs{}
    \PYG{n}{build}\PYG{o}{\PYGZhy{}}\PYG{n}{essential} \PYGZbs{}
    \PYG{n}{curl} \PYGZbs{}
    \PYG{n}{dpkg}\PYG{o}{\PYGZhy{}}\PYG{n}{sig} \PYGZbs{}
    \PYG{n}{libcap}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYGZbs{}
    \PYG{n}{libsqlite3}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYGZbs{}
    \PYG{n}{mercurial} \PYGZbs{}
    \PYG{n}{reprepro} \PYGZbs{}
    \PYG{n}{ruby1}\PYG{o}{.}\PYG{l+m+mf}{9.1} \PYGZbs{}
    \PYG{n}{ruby1}\PYG{o}{.}\PYG{l+m+mf}{9.1}\PYG{o}{\PYGZhy{}}\PYG{n}{dev} \PYGZbs{}
    \PYG{n}{s3cmd}\PYG{o}{=}\PYG{l+m+mf}{1.1}\PYG{o}{.}\PYG{o}{*} \PYGZbs{}
 \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rm} \PYG{o}{\PYGZhy{}}\PYG{n}{rf} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{apt}\PYG{o}{/}\PYG{n}{lists}\PYG{o}{/}\PYG{o}{*}
\end{sphinxVerbatim}

其中 \sphinxcode{\sphinxupquote{s3cmd}} 指令指定了一个版本号 \sphinxcode{\sphinxupquote{1.1.*}}。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 \sphinxcode{\sphinxupquote{apt-get udpate}} 缓存失效并确保安装的是新版本。

另外，清理掉 \sphinxcode{\sphinxupquote{apt}} 缓存 \sphinxcode{\sphinxupquote{var/lib/apt/lists}}可以减小镜像大小。因为 RUN 指令的开头为 \sphinxcode{\sphinxupquote{apt-get udpate}}，包缓存总是会在 \sphinxcode{\sphinxupquote{apt-get install}} 之前刷新。

注意：官方的 Debian 和 Ubuntu 镜像会自动运行 \sphinxcode{\sphinxupquote{apt-get clean}}，所以不需要显式的调用 \sphinxcode{\sphinxupquote{apt-get clean}}。


\subsubsection{CMD}
\label{\detokenize{docker/appendix:cmd}}
CMD 指令用于执行目标镜像中包含的软件，可以包含参数。CMD 大多数情况下都应该以 CMD {[}“executable”, “param1”, “param2”…{]} 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 Apache)，你可能会执行类似于 CMD {[}“apache2”, “-DFOREGROUND”{]} 形式的命令。我们建议任何服务镜像都使用这种形式的命令。

多数情况下，CMD 都需要一个交互式的 shell (bash, Python, perl 等)，例如 CMD {[}“perl”, “-de0”{]}，或者 CMD {[}“PHP”, “-a”{]}。使用这种形式意味着，当你执行类似 docker run -it python 时，你会进入一个准备好的 shell 中。CMD 应该在极少的情况下才能以 CMD {[}“param”, “param”{]} 的形式与 ENTRYPOINT 协同使用，除非你和你的镜像使用者都对 ENTRYPOINT 的工作方式十分熟悉。


\subsubsection{EXPOSE}
\label{\detokenize{docker/appendix:expose}}
EXPOSE 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 Apache web 服务的镜像应该使用 EXPOSE 80，而提供 MongoDB 服务的镜像使用 EXPOSE 27017。

对于外部访问，用户可以在执行 docker run 时使用一个标志来指示如何将指定的端口映射到所选择的端口。


\subsubsection{ENV}
\label{\detokenize{docker/appendix:env}}
为了方便新程序运行，你可以使用 ENV 来为容器中安装的程序更新 PATH 环境变量。例如使用 ENV PATH /usr/local/nginx/bin:\$PATH 来确保 CMD {[}“nginx”{]} 能正确运行。

ENV 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 PGDATA。

最后，ENV 也能用于设置常见的版本号，比如下面的示例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ENV PG\PYGZus{}MAJOR 9.3

ENV PG\PYGZus{}VERSION 9.3.4

RUN curl \PYGZhy{}SL http://example.com/postgres\PYGZhy{}\PYGZdl{}PG\PYGZus{}VERSION.tar.xz \textbar{} tar \PYGZhy{}xJC /usr/src/postgress \PYGZam{}\PYGZam{} …

ENV PATH /usr/local/postgres\PYGZhy{}\PYGZdl{}PG\PYGZus{}MAJOR/bin:\PYGZdl{}PATH
\end{sphinxVerbatim}

类似于程序中的常量，这种方法可以让你只需改变 ENV 指令来自动的改变容器中的软件版本。


\subsubsection{ADD 和 COPY}
\label{\detokenize{docker/appendix:add-copy}}
虽然 ADD 和 COPY 功能类似，但一般优先使用 COPY。因为它比 ADD 更透明。COPY 只支持简单将本地文件拷贝到容器中，而 ADD 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，ADD 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 ADD rootfs.tar.xz。

如果你的 Dockerfile 有多个步骤需要使用上下文中不同的文件。单独 COPY 每个文件，而不是一次性的 COPY 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{COPY} \PYG{n}{requirements}\PYG{o}{.}\PYG{n}{txt} \PYG{o}{/}\PYG{n}{tmp}\PYG{o}{/}

\PYG{n}{RUN} \PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{requirement} \PYG{o}{/}\PYG{n}{tmp}\PYG{o}{/}\PYG{n}{requirements}\PYG{o}{.}\PYG{n}{txt}

\PYG{n}{COPY} \PYG{o}{.} \PYG{o}{/}\PYG{n}{tmp}\PYG{o}{/}
\end{sphinxVerbatim}

如果将 \sphinxcode{\sphinxupquote{COPY . /tmp/}} 放置在 RUN 指令之前，只要 \sphinxcode{\sphinxupquote{.}} 目录中任何一个文件变化，都会导致后续指令的缓存失效。

为了让镜像尽量小，最好不要使用 ADD 指令从远程 URL 获取包，而是使用 curl 和 wget。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ADD} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{big}\PYG{o}{.}\PYG{n}{tar}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{things}\PYG{o}{/}

\PYG{n}{RUN} \PYG{n}{tar} \PYG{o}{\PYGZhy{}}\PYG{n}{xJf} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{things}\PYG{o}{/}\PYG{n}{big}\PYG{o}{.}\PYG{n}{tar}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{C} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{things}

\PYG{n}{RUN} \PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{C} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{things} \PYG{n+nb}{all}
\end{sphinxVerbatim}

而是应该使用下面这种方法：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{RUN} \PYG{n}{mkdir} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{things} \PYGZbs{}
    \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{curl} \PYG{o}{\PYGZhy{}}\PYG{n}{SL} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{big}\PYG{o}{.}\PYG{n}{tar}\PYG{o}{.}\PYG{n}{xz} \PYGZbs{}
    \PYG{o}{\textbar{}} \PYG{n}{tar} \PYG{o}{\PYGZhy{}}\PYG{n}{xJC} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{things} \PYGZbs{}
    \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{make} \PYG{o}{\PYGZhy{}}\PYG{n}{C} \PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{src}\PYG{o}{/}\PYG{n}{things} \PYG{n+nb}{all}
\end{sphinxVerbatim}

上面使用的管道操作，所以没有中间文件需要删除。

对于其他不需要 ADD 的自动提取功能的文件或目录，你应该使用 COPY。


\subsubsection{ENTRYPOINT}
\label{\detokenize{docker/appendix:entrypoint}}
\sphinxcode{\sphinxupquote{ENTRYPOINT}} 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用\sphinxcode{\sphinxupquote{CMD}} 提供默认选项）。

例如，下面的示例镜像提供了命令行工具 s3cmd:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ENTRYPOINT} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{s3cmd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

\PYG{n}{CMD} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}help}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

现在直接运行该镜像创建的容器会显示命令帮助：

\sphinxcode{\sphinxupquote{\$ docker run s3cmd}}
或者提供正确的参数来执行某个命令：

\sphinxcode{\sphinxupquote{\$ docker run s3cmd ls s3://mybucket}}
这样镜像名可以当成命令行的参考。

\sphinxcode{\sphinxupquote{ENTRYPOINT}} 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。

例如，Postgres 官方镜像使用下面的脚本作为 \sphinxcode{\sphinxupquote{ENTRYPOINT}}：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}!/bin/bash
set \PYGZhy{}e

if [ \PYGZdq{}\PYGZdl{}1\PYGZdq{} = \PYGZsq{}postgres\PYGZsq{} ]; then
    chown \PYGZhy{}R postgres \PYGZdq{}\PYGZdl{}PGDATA\PYGZdq{}

    if [ \PYGZhy{}z \PYGZdq{}\PYGZdl{}(ls \PYGZhy{}A \PYGZdq{}\PYGZdl{}PGDATA\PYGZdq{})\PYGZdq{} ]; then
        gosu postgres initdb
    fi

    exec gosu postgres \PYGZdq{}\PYGZdl{}@\PYGZdq{}
fi

exec \PYGZdq{}\PYGZdl{}@\PYGZdq{}
\end{sphinxVerbatim}

注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。

该辅助脚本被拷贝到容器，并在容器启动时通过 \sphinxcode{\sphinxupquote{ENTRYPOINT}} 执行：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{COPY} \PYG{o}{.}\PYG{o}{/}\PYG{n}{docker}\PYG{o}{\PYGZhy{}}\PYG{n}{entrypoint}\PYG{o}{.}\PYG{n}{sh} \PYG{o}{/}

\PYG{n}{ENTRYPOINT} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/docker\PYGZhy{}entrypoint.sh}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

该脚本可以让用户用几种不同的方式和 Postgres 交互。

你可以很简单地启动 Postgres：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} docker run postgres
\end{sphinxVerbatim}

也可以执行 Postgres 并传递参数：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} docker run postgres postgres \PYGZhy{}\PYGZhy{}help
\end{sphinxVerbatim}

最后，你还可以启动另外一个完全不同的工具，比如 Bash：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} docker run \PYGZhy{}\PYGZhy{}rm \PYGZhy{}it postgres bash
\end{sphinxVerbatim}


\subsubsection{VOLUME}
\label{\detokenize{docker/appendix:volume}}
\sphinxcode{\sphinxupquote{VOLUME}} 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 \sphinxcode{\sphinxupquote{VOLUME}} 来管理镜像中的可变部分和用户可以改变的部分。


\subsubsection{USER}
\label{\detokenize{docker/appendix:user}}
如果某个服务不需要特权执行，建议使用 USER 指令切换到非 root 用户。先在 Dockerfile 中使用类似 \sphinxcode{\sphinxupquote{RUN groupadd -r postgres \&\& useradd -r -g postgres postgres}} 的指令创建用户和用户组。

注意：在镜像中，用户和用户组每次被分配的 \sphinxcode{\sphinxupquote{UID/GID}} 都是不确定的，下次重新构建镜像时被分配到的 \sphinxcode{\sphinxupquote{UID/GID}} 可能会不一样。如果要依赖确定的 \sphinxcode{\sphinxupquote{UID/GID}}，你应该显示的指定一个 \sphinxcode{\sphinxupquote{UID/GID}}。

你应该避免使用 \sphinxcode{\sphinxupquote{sudo}}，因为它不可预期的 \sphinxcode{\sphinxupquote{TTY}} 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 sudo 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 \sphinxcode{\sphinxupquote{gosu}}。

最后，为了减少层数和复杂度，避免频繁地使用 USER 来回切换用户。


\subsubsection{WORKDIR}
\label{\detokenize{docker/appendix:workdir}}
为了清晰性和可靠性，你应该总是在 \sphinxcode{\sphinxupquote{WORKDIR}} 中使用绝对路径。另外，你应该使用 \sphinxcode{\sphinxupquote{WORKDIR}} 来替代类似于 \sphinxcode{\sphinxupquote{RUN cd ... \&\& do-something}} 的指令，后者难以阅读、排错和维护。


\section{最佳实践(container)}
\label{\detokenize{docker/appendix:container}}

\subsection{不要在启动时构建镜像}
\label{\detokenize{docker/appendix:id11}}
在使用\sphinxcode{\sphinxupquote{docker-compose}}编排工具时，不要使用\sphinxcode{\sphinxupquote{build}}参数指定构建上下文，在启动容器的时候，去构建镜像。应该使用\sphinxcode{\sphinxupquote{image}}直接引用已构建好的镜像。

应该把\sphinxcode{\sphinxupquote{Dockerfile}}作为源码的一部分维护，镜像是作为发布包对外的。在部署时，应该是用发布包，而不是用源码临时编译一套。
镜像可保证发布代码的强一致性。


\subsection{不要将容器当做虚拟机}
\label{\detokenize{docker/appendix:id12}}
docker是用来管理应用的，会使用linux中的\sphinxcode{\sphinxupquote{cgroups}}和\sphinxcode{\sphinxupquote{namespace}}做资源限制和资源隔离，不能当作虚拟机来。docker容器启动时，会根据设置的启动命令\sphinxcode{\sphinxupquote{CMD}}或者\sphinxcode{\sphinxupquote{ENTRYPOINT}}在容器中启动应用进程，无需手动进入容器中去启动。


\subsection{一个容器应只运行一个进程}
\label{\detokenize{docker/appendix:id13}}
https://yq.aliyun.com/articles/5545

通过将复杂应用解耦成一系列简单的进程、服务，可以更加简单的更新，运维和伸缩，符合微服务架构理念。同时单主进程应用可以大大简化容器内进程管理的复杂性。
如果需要运行多个进程，应使用如\sphinxhref{http://supervisord.org/}{supervisord}进程管理工具。


\subsection{提供HEALTHCHECK}
\label{\detokenize{docker/appendix:healthcheck}}
Docker默认是通过容器中的主进程是否退出来判断容器状态是否异常。但如果容器内进程进入死循环或者僵死状态，应用并没有退出，但其实容器已经无法提供服务。这时可以使用  \sphinxcode{\sphinxupquote{HEALTHCHECK}} 指定健康检测。

例如:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FROM} \PYG{n}{nginx}
\PYG{n}{RUN} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{update} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{y} \PYG{n}{curl} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{rm} \PYG{o}{\PYGZhy{}}\PYG{n}{rf} \PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{apt}\PYG{o}{/}\PYG{n}{lists}\PYG{o}{/}\PYG{o}{*}
\PYG{n}{HEALTHCHECK} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{interval}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{n}{s} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{n}{s} \PYGZbs{}
  \PYG{n}{CMD} \PYG{n}{curl} \PYG{o}{\PYGZhy{}}\PYG{n}{fs} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{localhost}\PYG{o}{/} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{exit} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\section{Q\&A}
\label{\detokenize{docker/appendix:q-a}}

\chapter{培训材料}
\label{\detokenize{docker/training:id1}}\label{\detokenize{docker/training::doc}}\begin{itemize}
\item {} 
\sphinxhref{https://yitutech-my.sharepoint.cn/:p:/r/personal/xiaohui\_liu\_yitu-inc\_com/\_layouts/15/WopiFrame.aspx?sourcedoc=\%7B306243f7-7200-4f43-bee3-daa66d363724\%7D\&action=default}{容器介绍}

\item {} 
\sphinxhref{https://yitutech-my.sharepoint.cn/:p:/g/personal/loulou\_liu\_yitu-inc\_com/Ecv5rb3lbO9MhD6J2xk1EUcBq5904Qqba9IlaENxlZOJfg?e=2KZoHv}{docker基础}

\end{itemize}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}